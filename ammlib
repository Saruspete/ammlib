# vim: ts=4 ft=sh

# AM Modular Library
# Main file, bootstrap and load dependencies
#
# To avoid uneeded library loading, some core / often used functions are here
# (they should be in their respective library file). Namely:
# Log Env Path Exec

# For future tools / loadables, consider this snippet
#[ -z "$BASH_LOADABLES_PATH" ] &&
#  BASH_LOADABLES_PATH=$(pkg-config bash --variable=loadablesdir 2>/dev/null)



set -u

export LC_ALL=C

# If no debug override has been done yet
if [[ -n "$PS4" ]] && [[ "$PS4" == "+ " ]]; then
	PS4=' (${BASH_SOURCE##*/}:$LINENO ${FUNCNAME[0]:-main})  '
fi


#
# Compatibility check
#

# Check if we are using bash, else try to load the wrapper
if [[ -z "$BASH" ]] || [[ "$(cat /proc/$$/comm)" != "bash" ]]; then
	# TODO Try to find a valid wrapper
	:
fi

# Minimal bash version
if [[ "${BASH_VERSINFO[0]:-}${BASH_VERSINFO[1]:-0}" -lt 42 ]]; then
	echo >&2 "This requires bash >= 4.2 to run."
	return 1 2>/dev/null
	exit 1
fi

# Enable extdebug to have arguments for trace
if [[ -n "${AMMLIB_DEBUG:-}" ]]; then
	shopt -s extdebug
fi

#
# Interactive and other calling methods specifics
#

# Check if we are started by a valid stdin
typeset -g  __AMMLIB_TTY="$(tty)"
typeset -g  __AMMLIB_INTERACTIVE=true
if [[ -z "$__AMMLIB_TTY" ]] || ! [[ -e $__AMMLIB_TTY ]]; then
	__AMMLIB_TTY=""
	__AMMLIB_INTERACTIVE=false
fi
typeset -g  __AMMLIB_STDOUTPIPED=false
if ! [[ -t 1 ]]; then
	__AMMLIB_STDOUTPIPED=true
fi

if $__AMMLIB_INTERACTIVE; then
	PS4="\033[2m$PS4\033[0m"
fi

#
# Path management
#

# @description  Path where ammlib is
typeset -g  __AMMLIB_REALPATH="$(realpath ${BASH_SOURCE[0]} 2>/dev/null)"

# Check the readlink usability
if type -t realpath >/dev/null; then
	if ! [[ "$(realpath "$__AMMLIB_REALPATH")" -ef "$__AMMLIB_REALPATH" ]]; then
		echo "realpath exists ($(type "realpath")) but does not behave properly."
		echo "Please check your existing environment before retrying. Stopping here."
		if $__AMMLIB_INTERACTIVE; then
			echo "(press any key to exit)"
			read -s -n 1 key
		else
			echo "Exiting"
		fi
		exit 1
	fi
fi

# @description  Options passed to the script ($@)
typeset -ga __AMMLIB_CALLOPTS=("$@")
typeset -gra __AMMLIB_CALLOPTS_ORIG=("$@")
# Empty array being unset is fixed in bash 4.4
if [[ "${BASH_VERSINFO[0]}" -eq 4 ]] && [[ "${BASH_VERSINFO[1]}" -lt 4 ]]; then
	[[ -z "$@" ]] && __AMMLIB_CALLOPTS=("")
fi

# Check for stdin load (cat|bash  or bash -c "...")
if [[ -z "$0" ]] || ! [[ -e "$0" ]]; then
	typeset -gr __AMMLIB_CALLNAME="stdin.$0.$$"
	typeset -gr __AMMLIB_CALLFILE="stdin.$0.$$"
	typeset -gr __AMMLIB_CALLPATH="$(pwd -P)"
else
	# @description  How the script was called ($0)
	typeset -gr __AMMLIB_CALLNAME="$0"
	# @description  Name of the file that was called
	typeset -gr  __AMMLIB_CALLFILE="${0##*/}"
	# Set in 2-times to avoid bug "h" fixed in 4.4-rc1 (make_cmd.c:801)
	typeset -g  __AMMLIB_CALLPATH="$(realpath "${BASH_SOURCE[-1]%/*}")"
fi


# @description  The file that loaded ammlib
typeset -gr __AMMLIB_LOADERFILE="${BASH_SOURCE[1]:-stdin}"

typeset -gr __AMMLIB_USERNAME="$(\id -nu)"
typeset -gr __AMMLIB_USERID="${UID:-$(\id -u)}"
typeset -gr __AMMLIB_HOSTNAME="$(uname -n)"
#
# Set and create base folders to be used by library
#

# Library scripts base path
typeset -g __AMMLIB_ROOT="${__AMMLIB_REALPATH%/*}"

# Allows to customize our usage by another app
typeset -g __AMMLIB_APPNAME="${AMMLIB_APPNAME:-ammlib}"

# Temporary data
typeset -g __AMMLIB_DATATMP="/tmp/.${__AMMLIB_APPNAME}.${__AMMLIB_USERID}/${__AMMLIB_CALLNAME##*/}.$$"
[[ -d "$__AMMLIB_DATATMP" ]] || mkdir -p "$__AMMLIB_DATATMP"

# Persistant data
typeset -g __AMMLIB_DATA="$HOME/.${__AMMLIB_APPNAME}/data/"
[[ -d "$__AMMLIB_DATA" ]] || mkdir -p "$__AMMLIB_DATA"

# Custom binaries
typeset -g __AMMLIB_BIN="$HOME/.${__AMMLIB_APPNAME}/bin"
[[ -d "$__AMMLIB_BIN" ]] || mkdir -p "$__AMMLIB_BIN"
export PATH+=":$__AMMLIB_BIN"

# -----------------------------------------------------------------------------
# Data management
# -----------------------------------------------------------------------------

function ammLib::_PathGetForCaller {
	typeset prefix="$1"
	typeset suffix="${2:-}"

	# Get name and path from caller
	typeset callingstr="$(ammLog::Stackdump 3 1)"
	typeset callingfile="${callingstr%%:*}"

	typeset dir="$prefix/$callingfile/$suffix"
	! [[ -d "$dir" ]] && mkdir -p "$dir"
	if ! [[ -d "$dir" ]]; then
		ammLog::Error "Error during creation of path '$dir'. Please check"
		return 1
	fi

	echo "$dir"
}

function ammLib::DataPathGet {
	typeset extra="${1:-}"
	ammLib::_PathGetForCaller "$__AMMLIB_DATA" "$extra"
}

function ammLib::TmpPathGet {
	typeset extra="${1:-}"
	ammLib::_PathGetForCaller "$__AMMLIB_DATATMP" "$extra"
}

# -----------------------------------------------------------------------------
# Hooks and events
# -----------------------------------------------------------------------------

typeset -gA __AMMLIB_HOOKLIST
# This module will register dynamic arrays based on name + prefix __AMMHOOK_

# @description  Will generate a variable ID from a given name
function ammLib::HookNameToVarname {
	typeset -u name="$1"

	# Remove any non-alphanum char
	name="${name//[^a-zA-Z0-9]/}"
	echo "__AMMLIB_HOOK_$name"
}

function ammLib::HookExists {
	typeset name="$1"

	typeset id="$(ammLib::HookNameToVarname "$name")"
	# Got to use eval, typeset -n is from bash 4.3
	eval "(set +u; [[ -n \${${id}} ]] )"
}

# @description  Register a callback to a hook
# @arg $1  (string) Name of the hook to register
# @arg $2  (function) Callback
function ammLib::HookRegister {
	typeset name="$1"; shift

	typeset varname="$(ammLib::HookNameToVarname "$name")"
	# Create the hook first if not existing
	if ! ammLib::HookExists $name; then
		ammLog::Debug "Registering cb '$@' to new hook '$name'"
		eval "$varname=('$@')"
		__AMMLIB_HOOKLIST["$varname"]="$name"
	else
		ammLog::Debug "Registering cb '$@' to existing hook '$name'"
		eval "$varname+=('$@')"
		__AMMLIB_HOOKLIST["$varname"]+=" $name"
	fi
}

function ammLib::HookList {
	echo "${!__AMMLIB_HOOKLIST[@]}"
}

# @description  List registered callbacks for an even
# @arg $1  (string) name of the hook to list callbacks
function ammLib::HookListCallbacks {
	typeset name="$1"

	typeset varname="$(ammLib::HookNameToVarname "$name")"
	typeset callback callbackid
	for callbackid in $(eval 'echo ${!'$varname'[@]}'); do
		eval echo '${'${varname}'['${callbackid}']};'
	done
}

# @description  Trigger a hook
# @arg $1  (string) Name of the hook to trigger
# @arg $@  (string) arguments to pass to the callbacks
function ammLib::HookTrigger {
	typeset name="$1"; shift

	ammLog::Debug "Triggering callbacks for '$name'"

	typeset callback args
	while read callback args; do
		if ! ammEnv::IsFunc "$callback"; then
			ammLog::Warning "Callback '$callback' is not a function. Skipping it"
			continue
		fi
		ammLog::Debug "Calling callback '$callback $args' with '$@'"
		$callback $args "$@"
	done < <(ammLib::HookListCallbacks "$name")
}

# -----------------------------------------------------------------------------
# Exit code and trap management
# -----------------------------------------------------------------------------
typeset -gA __AMMLIB_SIGNALS
typeset -gA __AMMLIB_TRAP_CALLBACKS
typeset -gA __AMMLIB_TRAP_REGISTERED
typeset -gi __AMMLIB_TRAP_WAITMAX=30
typeset -g  __AMMLIB_TRAP_WAITSTEP=1


# @description  Initialize and registers the signal handling trap
# @arg $@  Signals to be traped
function ammLib::_TrapInit {

	# Populate avaialble signals array from "trap -l" output
	if (set +u; [[ ${#__AMMLIB_SIGNALS[@]} -eq 0 ]]); then
		typeset s signum
		for s in "0)" "SIGEXIT" $(trap -l); do
			[[ "${s%)}" != "$s" ]] && signum="${s%)}"
			# Register num=>name and name=>num but skip invalid sigs
			if [[ "${s#SIG}" != "$s" ]] && [[ "${s#SIGRTM*}" == "$s" ]]; then
				__AMMLIB_SIGNALS[$signum]="${s#SIG}"
				__AMMLIB_SIGNALS[${s#SIG}]="$signum"
			fi
		done
	fi

	# Register trap with the signals as argument
	for s in "$@"; do
		trap "ammLib::_TrapHandler $s" "$s"
		__AMMLIB_TRAP_REGISTERED[$s]="ok"
	done
}

# @description  Registers a callback
# @arg $1  The callback to call upon trap
# @arg $@  The signals to register on. Can be alises: EXITALL or EXITERR
function ammLib::TrapRegister {
	typeset callback="$1"; shift

	typeset signame
	for signame in "$@"; do
		case $signame in
			# Special alises
			EXITALL) ammLib::TrapRegister "$callback" EXIT HUP INT TERM QUIT ILL ABRT ;;
			EXITERR) ammLib::TrapRegister "$callback"      HUP INT TERM QUIT ILL ABRT ;;
			# Check for signal validity
			*)
				if (set -u; [[ -n "${__AMMLIB_SIGNALS[$signame]}" ]] ); then
					__AMMLIB_TRAP_CALLBACKS[$signame]+="$callback "
					if ! ( set +u; [[ -n "${__AMMLIB_TRAP_REGISTERED[$signame]}" ]] ); then
						ammLog::Debug "Registered callback with uninit signal. Registering signal:$signame for callback:$callback"
						ammLib::_TrapInit "$signame"
					fi
				else
					ammLog::Warning "Invalid signal to register callback: signal:$signame callback:$callback"
				fi
				;;
		esac
	done

}

function ammLib::TrapClean {

	ammLib::HookTrigger "exit"

	# clean global temp vars
	if [[ -n ${AMMLIB_DEBUG:-} ]]; then
		if ( shopt -s nullglob dotglob; f=($__AMMLIB_DATATMP/*); [[ ${#f[@]} -gt 0 ]] ); then
			ammLog::Info "Debug enabled: Keeping non-empty temporary path '$__AMMLIB_DATATMP'"
		else
			ammLog::Info "Removing empty temporary path '$__AMMLIB_DATATMP'"
			[[ -d "$__AMMLIB_DATATMP" ]] && rmdir "$__AMMLIB_DATATMP"
		fi
	else
		[[ -d "$__AMMLIB_DATATMP" ]] && rm -fr "$__AMMLIB_DATATMP"
	fi
}

# Can't catch KILL CONT STOP
ammLib::_TrapInit EXIT HUP INT TERM QUIT ILL ABRT TSTP USR1 USR2
ammLib::TrapRegister "ammLib::TrapClean" EXITALL

# EXIT: Pseudo signal, standard exit of bash
# INT : Interrupt, Ctrl + C
# TERM: Default kill signal, graceful shutdown
# QUIT: Key "QUIT" (or Ctrl \) not on all keyboards
# ABRT: Call of abort(), usually by libc for ptmalloc errors
# TSTP: Stopped (Ctrl + Z)

# @description  (private) TRAP handler to clean
# @arg $1  Name of the signal
function ammLib::_TrapHandler {
	typeset retcode=$?
	typeset signame="$1"
	typeset sigtype=""
	typeset retaction="return"

	ammLog::Debug "Caught signal '$signame' with retcode $retcode"
	case $signame in
		# Standard shutdown
		EXIT)
			sigtype="EXITOK"

			# Wait for unfinished jobs
			if [[ -n "$(jobs)" ]] && [[ $__AMMLIB_TRAP_WAITMAX -gt 0 ]]; then
				ammLog::Info "Waiting unfinished jobs in background for $__AMMLIB_TRAP_WAITMAX checks every $__AMMLIB_TRAP_WAITSTEP sec"
				typeset num pid state cmd
				typeset -i waitjob=0
				while [[ $waitjob -lt $__AMMLIB_TRAP_WAITMAX ]]; do
					typeset -i jobcnt=0
					ammLog::Info "== Check $waitjob $(ammLog::Time)"
					while read num pid state cmd; do
						[[ "$pid" == "$$" ]] && continue
						ammLog::Info "PID:$pid State:$state Command:$cmd"
						jobcnt+=1
					done < <(jobs -lr)
					[[ $jobcnt -eq 0 ]] && break
					waitjob+=1
					sleep $__AMMLIB_TRAP_WAITSTEP
				done

				if [[ $waitjob -eq $__AMMLIB_TRAP_WAITMAX ]]; then
					ammLog::Warning "Hit timeout before all background jobs finished. Remains:"
					jobs -l | ammLog::Warning -
				fi
			fi
			;;

		# Manual stop
		INT|HUP|TERM|QUIT)
			sigtype="EXITERR"
			ammLog::Warning "Caught graceful interruption $signame. Cleaning"
			retaction="exit"
			;;

		# Unamanged return code
		'')
			ammLog::Warning "Called with empty signal name..."
			;;

		*)
			ammLog::Warning "Unhandled signal name '$signame'"
			;;
	esac

	# Execute Callbacks for signame
	if ( set +u; [[ -n "${__AMMLIB_TRAP_CALLBACKS[$signame]}" ]] ); then
		typeset callback
		for callback in ${__AMMLIB_TRAP_CALLBACKS[$signame]}; do
			ammLog::Debug "Calling callback $callback"
			$callback "$signame"
			ammLog::Debug "Callback done. Retcode: $?"
		done
	fi

	# Try last hook there
	if [[ "$retaction" == "exit" ]]; then
		ammLib::HookTrigger "exit"
	fi

	# Do the exit or return
	$retaction $retcode
}


# -----------------------------------------------------------------------------
# Module loading
# -----------------------------------------------------------------------------
typeset -g __AMMLIB_SEARCHPATH="${__AMMLIB_ROOT}/lib"
typeset -g __AMMLIB_LOADED="ammlib lib"

# @description  Locate the library file matching given name
# @arg $1  (string) Name of the library to be loaded (eg, process)
# @stdout  (path) Path of the first matching file (in $__AMMLIB_SEARCHPATH)
function ammLib::Locate {
	typeset libname="$1"

	typeset libpath
	typeset searchextra="${AMMLIB_SEARCHPATH_EXTRA:-}"
	typeset searchoverride="${AMMLIB_SEARCHPATH_OVERRIDE:-}"
	for libpath in ${searchoverride//:/ } $__AMMLIB_SEARCHPATH ${searchextra//:/ }; do
			typeset nlib="${libpath}/${libname}.lib"
			if [[ -f "$nlib" ]] && [[ -r "$nlib" ]]; then
				echo "$nlib"
				return
			fi
	done
	return 1
}

# @description  Locate all libraries that starts with the given pattern
# @arg $1  The pattern to search against
# @stdout  (path) the list of libraries that matches the given pattern
function ammLib::LocatePattern {
	typeset libpattern="$1"

	typeset libpath lib
	typeset searchextra="${AMMLIB_SEARCHPATH_EXTRA:-}"
	typeset searchoverride="${AMMLIB_SEARCHPATH_OVERRIDE:-}"
	for libpath in ${searchoverride//:/ } $__AMMLIB_SEARCHPATH ${searchextra//:/ }; do
		for lib in $libpath/$libpattern*.lib; do
			echo "$lib"
		done
	done
}

# @descripton  return the library name of a given file
# @arg $1  (path) The file path to get the name from
# @stdout  (string) name of the library
function ammLib::NameFromPath {
	typeset path="$1"

	path="${path##*/}"
	path="${path%.lib}"

	echo "$path"
}

# @description  List all symbols and functions for packing
# @arg $@  (path[]) List of files to extract symbols from
function ammLib::GetSymbols {
	for file in "$@"; do
		grep -Po '^[\s]*(function[\s]+[^\s]+|[^\s]+\(\))[\s]*{' $file | awk '
			/function[ ]+([^ ]+)/ {print $2}
			/[^ ]+[ ]*()/ { gsub(/[()]/,"",$1); print $1 }'
		grep -Po '^[\s]*(typeset|declare|readonly)([\s]+-[a-zA-Z]+)?[\s]+__[^\s]+=' "$file" | awk '
			{gsub(/=$/,"",$NF); print $NF; }'
	done
}

# @description  Check if the given libname is a sub-library
# @exitcode  0 on success
function ammLib::IsSublib {
	typeset libname="$1"
	[[ "${libname//./}" != "$libname" ]]
}

# @description  Check if a given libname is loaded
# @exitcode  0 if loaded
function ammLib::IsLoaded {
	typeset libname="$1"

	typeset l=""
	for l in $__AMMLIB_LOADED; do
		[[ "$l" == "$libname" ]] && return 0
	done

	return 1
}


# @description  Get the function name for the library' constructor
# @arg $1  (string) library name
function ammLib::MetaGetPrefix {
	typeset libname="$1"

	# Input name is lowercase. Up only first char: main => Main
	typeset funcpref="${libname^}"

	# If it's a sub-library, prefix is MainSub
	if ammLib::IsSublib "$libname"; then
		# Reset the prefix
		funcpref=""
		for f in ${libname//./ }; do
			funcpref+=${f^}
		done
	fi

	echo "amm${funcpref}::Meta"
}

# @description  Test if a library is loadable (MetaCheck) and display its path
# @arg $@  (string[]) Name of the library
# @exitcode 0  If all modules are loadable
# @exitcode 1+ if one or more module cannot be loaded
function ammLib::Loadable {

	typeset -i r=0

	ammLog::Dbg "Checking if libs are loadable: $@"

	typeset arg=""
	for arg in "$@"; do
		typeset libfile="" libname=""

		# If the provide arg is an absolute path to a file
		if [[ "${arg:0:1}" == "/" ]] && [[ -s "$arg" ]]; then
			libfile="$arg"
			libname="$(ammLib::NameFromPath $libfile)"

		# Else, find our file
		else
			libname="$arg"
			libfile="$(ammLib::Locate "$libname")"
		fi

		# If the lib exists, load it
		ammLog::Debug "Checking if '$libfile' is a valid library"
		if [[ -n "$libfile" ]] && [[ -f "$libfile" ]] && [[ -s "$libfile" ]]; then

			# try to load it in a subshell to check init
			typeset metapref="$(ammLib::MetaGetPrefix "$libname")"
			typeset metatext=""

			# Display the lib file before the test to have its path in error messages
			echo "$libfile"

			# check for features starting from bash 4.2 (typeset -g)
			if [[ "${BASH_VERSINFO[0]:-0}" -eq "4" ]] && [[ "${BASH_VERSINFO[1]:-0}" -lt 2 ]]; then
				if grep -P '(typeset|declare) -[a-zA-Z]*g[a-zA-Z]* ' $libfile >/dev/null 2>&1; then
					ammLog::Debug "Library '$libfile' needs bash >= 4.2"
					r+=1
					continue
				fi
			fi

			# Code 98 = fail during the load (parsing error ?)
			metatext="$(ammLog::Silence onlyerr; . $libfile || exit 98; if \type ${metapref}Check >/dev/null 2>&1; then ${metapref}Check >/dev/null; exit $?; else exit 0; fi;)"

			# Dont stop loading, just log error and increase return
			if [[ $? -ne 0 ]]; then
				ammLog::Debug "Unable to load lib '$libname' (file '$libfile'). Init check failed: '$metatext'"
				r=r+1
				continue
			fi

		# Unable to load the lib
		else
			ammLog::Debug "Unable to locate library '$libname'"
			r+=1
		fi
	done

	return $r
}


# @description  Load a library
# @arg $@  (string[]) Library name to be loaded
# @exitcode 0 if all modules were loaded successfully
# @exitcode 1+ if one or more module failed to load
function ammLib::Load {
	typeset -i r=0

	typeset libname="" l=
	for libname in "$@"; do
		typeset libfile=""

		# Check if we've been given a filename or a filepath
		if [[ "${libname//\//}" != "$libname" ]]; then
			libfile="$libname"
			libname="$(ammLib::NameFromPath "$libname")"
		fi

		libname="${libname//\"/}"
		libname="${libname//\'/}"


		# For submodule, you need to load parent module first
		if ammLib::IsSublib "$libname"; then

			# If the name is indeed a submodule, stop here
			typeset parentlib="${libname%.*}"
			typeset parentlibpath="$(ammLib::Locate "$parentlib")"
			if [[ -n "$parentlibpath" ]]; then

				typeset parentloaded=
				ammLib::IsLoaded "$parentlib" && parentloaded="$parentlib"

				if [[ -z "$parentloaded" ]]; then
					ammLog::Error "Cannot load '$libname' with ammLib::Load: look like a sub-lib of '$parentlib' and its parent '$parentlib' is not loaded"
					r=r+1
					continue
				fi
			fi
		fi

		# Skip already loaded libraries
		ammLib::IsLoaded "$libname" && continue

		typeset libavailable=1

		# Check if libfile is already provided from input
		if [[ -n "$libfile" ]]; then
			if [[ -e "$libfile" ]]; then
				if ! [[ "$libfile" -ef "$(ammLib::Locate "$libname")" ]]; then
					ammLog::Warning "Will load provided file '$libfile' for '$libname' that is not the one found by ammLib::Locate: '$(ammLib::Locate "$libname")'"
				fi

				libavailable=0
			fi
		else
			libfile="$(ammLib::Loadable "$libname")"
			libavailable=$?
		fi

		# Check if we can load requested lib
		if [[ $libavailable -eq 0 ]]; then

			# Add lib early to avoid within-module reloading
			__AMMLIB_LOADED+=" $libname"

			ammLib::HookTrigger "before:libload:$libname"

			# Init was ok, source and use lib
			. "$libfile"

			# Call init
			typeset metapref="$(ammLib::MetaGetPrefix "$libname")"
			if ammEnv::IsFunc "${metapref}Init"; then
				ammLog::Debug "Calling init '${metapref}Init'"
				#${metapref}Init || ammLog::Die "Error during init call of '${metapref}Init'"
				${metapref}Init >/dev/null
				[[ $? -ne 0 ]] && ammLog::Warning "Non-zero return from ${metapref}Init"
			else
				ammLog::Debug "No init function (${metapref}Init) in '$libfile'"
			fi

			ammLib::HookTrigger "after:libload:$libname"

			continue

		else
			if [[ -n "$libfile" ]] && [[ -s "$libfile" ]]; then
				ammLog::Error "Unable to load lib '$libname' due to failed init (enable debug with AMMLIB_DEBUG=Lib for full detail)"
			else
				ammLog::Error "Unable to locate library '$libname' in search path '$__AMMLIB_SEARCHPATH'"
			fi

			r=r+1
		fi
	done

	return $r
}

# @description  Unload a module from the current session
# @arg $@   (string[]) List of modules to unload
function ammLib::Unload {
	typeset -i r=0

	# Find 
	typeset libname
	for libname in "$@"; do
		typeset libfile l
		# Check if lib was loaded
		for l in $__AMMLIB_LOADED; do
			# Not loaded
			[[ "$libname" == "$l" ]] && {
				libfile="$(ammLib::Locate "$libname")"
				continue
			}
		done

		# Skip non-loaded / non-found libraries
		[[ -z "$libfile" ]] && continue

		# Remove symbols (functions)
		typeset sym
		for sym in $(ammLib::GetSymbols "$libfile"); do
			unset $sym
		done

	done
}

# @description  Similar to ammLibLoad but exit if a module cannot be loaded
# @arg $@  (string[]) List of modules to be loaded
function ammLib::Require {
	for libname in "$@"; do

		# Spawn it in a subshell to accomodate all potential exec / checks
		ammLog::Debug "Trying to load required lib '$libname'"
		if ! ammLib::Load "$libname"; then
			ammLog::Error "Unable to load required library '$libname'. Exiting"
			exit 1
		fi
	done

	return 0
}

# Compact all libraries to a single file, to be embedded in scripts
function ammLib::Compact {
	:
}

# @description List modules currently available
# @noargs
function ammLib::ListModules {

	typeset libpath lib
	for libpath in $(ammLib::LocatePattern); do
		[[ -s "$libpath" ]] || continue
		typeset lib=${libpath##*/}
		lib=${lib%.lib}

		echo
		echo "====== $lib ($libpath)"
	done
}

function ammLib::ListFunctions {
	typeset filename="${1:-}"

	typeset file
	for file in $(ammLib::LocatePattern $filename); do
		ammLib::GetSymbols "$file"
	done
}

# -----------------------------------------------------------------------------
# Embedded Logging
# -----------------------------------------------------------------------------

function ammLog::_ColorJoin {
	typeset IFS="$1"; shift
	echo "$*"
}

typeset -gA __AMMLOG_TERMCODES=(
	# Set
	[reset]=0 [bold]=1 [dim]=2 [underline]=4 [blink]=5 [reverse]=7 [hidden]=8
	# Reset
	[resetbold]=21 [resetdim]=22 [resetunderline]=24 [resetblink]=25 [resetreverse]=27 [resethidden]=28
	# Foreground Colors
	[black]=30 [red]=31 [green]=32 [yellow]=33 [blue]=34 [magenta]=35 [cyan]=36 [white]=37 [default]=39
	# Background Colors
	[bgblack]=40 [bgred]=41 [bggreen]=42 [bgyellow]=43 [bgblue]=44 [bgmagenta]=45 [bgcyan]=46 [bgwhite]=47 [bgdefault]=49
	# Foreground Colors Light
	[lightred]=91 [lightgreen]=92 [lightyellow]=93 [lightblue]=94 [lightmagenta]=95 [lightcyan]=96 [lightwhite]=97
	# Background Colors Light
	[bglightblack]=100 [bglightred]=101 [bglightgreen]=102 [bglightyellow]=103 [bglightblue]=104 [bglightmagenta]=105 [bglightcyan]=106 [bglightwhite]=107 [bglightdefault]=109
)

typeset -gi __AMMLOG_VERBOSITY=1
typeset -gi __AMMLOG_DEPTH=0

# @description  Colorize the text with values in __AMMLOG_TERMCODES
# @$ color codes to be printed
function ammLog::Color {
	typeset -r esc="\033["
	typeset -a codes=()

	# TODO: Handle truecolor. See https://gist.github.com/XVilka/8346728
	while [[ -n "${1-}" ]]; do
		[[ -n "${__AMMLOG_TERMCODES[$1]-}" ]] && codes[${#codes[@]}+1]="${__AMMLOG_TERMCODES[$1]}"
		shift
	done

	echo -ne "${esc}$(ammLog::_ColorJoin ";" ${codes[@]+"${codes[@]}"})m"
}

# @description  Returns the Time for the logs
# @noargs
# @stdout  Date format HH:MM:SS
function ammLog::Time {
	date '+%H:%M:%S'
}

# @description  Returns the Date for the logs
# @noargs
# @stdout  Dat format yyyy-mm-dd
function ammLog::Date {
	date '+%y-%m-%d'
}

# @description  Checks if AMMLIB_DEBUG variable is set and needs to do some job
function ammLog::_DbgIsEnabled {
	# Early tests
	[[ $__AMMLOG_VERBOSITY -ge 2 ]] && return 0
	[[ -z "${AMMLIB_DEBUG:-}" ]] && return 1
	[[ "$AMMLIB_DEBUG" == "all" ]] && return 0

	# Remove leading "amm"
	typeset func="${1##amm}"

	# If the lib is within the debug, or only the func
	if [[ "${AMMLIB_DEBUG//$func/}" != "$AMMLIB_DEBUG" ]] || [[ "$AMMLIB_DEBUG" =~ (^|,)${func%%::*}(,|$) ]]; then
		return 0
	fi
	return 1
}


# Log will be out to stdout
typeset -g __AMMLOG_FDSTD=97
typeset -g __AMMLOG_FDERR=98
exec 97>&1 98>&2 # Must be plain int, not the variable
typeset -g __AMMLOG_FDDBG=99
typeset -g __AMMLOG_LOGFILE=""
typeset -g __AMMLOG_LOGTERM=""
typeset -g __AMMLOG_SILENT="0"

typeset -gi __AMMLOG_STEPDEPTH=0
typeset -ga __AMMLOG_STEPTIME
typeset -ga __AMMLOG_STEPNAME

# @description  (private) Generic log function for logging
# @arg $1  (string) tag
# @arg $2  (string) format, passed to ammLog::Color, thus keys of $__AMMLOG_TERMCODES
# @arg $@  (string[]) Text to be logged. If only "-", read as stdin.
# @stdout  (string) Resulting log
function ammLog::_Log {
	# Remove tracing if enabled to limit spam
	typeset redbg=""
	[[ "${-//x/}" != "$-" ]] && { set +x; redbg="set -x"; }

	typeset tag="$1"; shift
	typeset fmt="$1"; shift

	typeset color="$(ammLog::Color $fmt)"
	typeset colorrst="$(ammLog::Color reset)"
	typeset date="$(ammLog::Time)"
	typeset pad="$(ammLog::_StepPad)"


	# Read stdin
	if [[ "$@" = "-" ]]; then
		typeset line
		while read line; do
			# Silent mode doesn't write any log
			if [[ "$__AMMLOG_SILENT" == "0" ]]; then
				echo >&$__AMMLOG_FDSTD -e "${color}[$date][$tag][$$]$pad $line${colorrst}"
			# Special case: only error on stdout
			elif [[ "$__AMMLOG_SILENT" == "2" ]] && [[ "$tag" == "ERR" ]]; then
				echo "[$date][$tag][$$]$pad $line"
			fi

			if [[ -n "${__AMMLOG_LOGFILE:-}" ]] && [[ -w "$__AMMLOG_LOGFILE" ]]; then
				echo >>"$__AMMLOG_LOGFILE"  "[$date][$tag][$$]$pad $line"
			fi
		done

	# Standard args
	else
		# Silent mode doesn't display any log
		if [[ "$__AMMLOG_SILENT" == "0" ]]; then
			echo >&$__AMMLOG_FDSTD -e "${color}[$date][$tag][$$]$pad $@${colorrst}"
		elif [[ "$__AMMLOG_SILENT" == "2" ]] && [[ "$tag" == "ERR" ]]; then
			echo "[$date][$tag][$$]$pad $@"
		fi

		if [[ -n "${__AMMLOG_LOGFILE:-}" ]] && [[ -w "$__AMMLOG_LOGFILE" ]]; then
			echo >>"$__AMMLOG_LOGFILE"  "[$date][$tag][$$]$pad $@"
		fi
	fi

	# Restart tracing if was enabled
	$redbg
}


function ammLog::_Write {
	typeset tar="$1"; shift
	typeset fmt="$2"; shift
	typeset color=""
}

# @description  Log a fatal error and terminate script
# @arg $@  Log text for fatal error. If "-", text is read from stdin
function ammLog::Die {
	ammLog::_Log "DIE" "bold red reverse" "$@"
	exit 255
}

# @description  Log an error
# @arg $@  Error text to log. If "-", text is read from stdin
function ammLog::Error {
	# TODO: add calling path
	ammLog::_Log "ERR" "bold red" "$@"
}

# @description  Log a warning
# @arg $@  warning text to log. If "-", text is read from stdin
function ammLog::Warning {
	ammLog::_Log "WRN" "bold yellow" "$@"
}

# @description  Log an information
# @arg $@  Info text to log. If "-", text is read from stdin
function ammLog::Info {
	ammLog::_Log "INF" "bold green" "$@"
}

function ammLog::Notice {
	ammLog::_Log "INF" "bold green" "$@"
}


# @description  Log a debug info
# @arg $@  Debug text to log. If "-", text is read from stdin
function ammLog::Debug {

	# Remove tracing if enabled to limit spam
	typeset redbg=""
	# "shopt -q -o xtrace" seems faster (not by much)
	[[ "${-//x/}" != "$-" ]] && { set +x; redbg="set -x"; }

	# Only send to log on verbose level
	#if [[ -n "${AMMLIB_DEBUG:-}" ]] || [[ $__AMMLOG_VERBOSITY -ge 2 ]]; then
	if ammLog::_DbgIsEnabled "${FUNCNAME[1]}"; then
		# Get the caller
		typeset callerdbg="${BASH_SOURCE[1]##*/}:${BASH_LINENO[0]} ${FUNCNAME[1]}"

		ammLog::_Log "DBG" "bold blue reverse" "[$callerdbg] $@"

	# Else, we must consume stdin or bash will fail (and add to stack nonetheless)
	else
		if [[ "$1" == "-" ]]; then
			while read line; do
				: # echo "$line" >> "${__AMMLOG_DBGFILE}.${_AMMLOG_DEPTH}"
			done
		else
			: # echo "$@" >> "${__AMMLOG_DBGFILE}.${_AMMLOG_DEPTH}"
		fi
	fi

	# Restart tracing if was enabled
	$redbg
}

# Legacy helpers
function ammLog::Err { ammLog::Error "$@"; }
function ammLog::Inf { ammLog::Info "$@"; }
function ammLog::Wrn { ammLog::Warning "$@"; }
function ammLog::Dbg { ammLog::Debug "$@"; }




# @description  Log a warning about function deprecation
function ammLog::Deprecated {
	typeset replacement="$1"; shift

	typeset callee="$(ammLog::Stackdump 2 1)"
	typeset callstack="$(ammLog::Stackdump 3 1)"

	ammLog::Warning "Function '$callee' (called from $callstack) is deprectated. Update your code to use '$replacement' instead"

	$replacement "$@"
}

# @description  Set a function as unavailable
# @arg $1  function
# @arg $2  reason
function ammLog::UnavailableFunc {
	typeset func="$1"
	typeset reason="${2:-unspecified reason}"

	typeset origin="$(ammLog::Stackdump 2 1)"

	# Some security
	typeset lib="${func%%::*}"
	case $lib in
		ammLib|ammLog|ammEnv)
			ammLog::Err "It's unlikely you want to set core function unavailable... (from $origin)"
			return 1
			;;
	esac

	# Override the function with a message
	ammLog::Warning "Disabling function '$func' from '$origin': $reason"
	eval "function $func { ammLog::Error 'Cannot call $func: function is disabled because $reason ($origin)'; }"
}


function ammLog::_StepPad {
	typeset step="${1:-$__AMMLOG_STEPDEPTH}"

	typeset i
	for (( i=0; i < $step; i++ )); do
		echo -n "  "
	done
}

# @description  Displays a separator with optionnal text on the middle
# @arg $1  (string) The message to be between the separators
# @arg $2  (string) The char to be used as separator. default '='
function ammLog::EchoSeparator {
	typeset msg="${1:-}"
	typeset chr="${2:-=}"

	typeset cols="${COLUMNS:-$(tput cols)}"
	typeset -i msgSize=${#msg}
	typeset -i sepSize=$(( $cols - $msgSize))
	[[ $sepSize -lt 0 ]] && sepSize=10

	# If we have a message, remove 2 chars as separator before & after message
	[[ ${msgSize} -gt 0 ]] && sepSize+=-2
	sepSize=$(($sepSize/2))

	typeset sep=""
	typeset -i i=0
	for ((i=0; i<$sepSize; i++)); do
		sep+="$chr"
	done
	echo "$sep${msg:+ $msg }$sep"
}

# @description  Show a visible step separator
function ammLog::Step {
	typeset name="$1"

	typeset cols="${COLUMNS:-$(tput cols)}"
	[[ -z "$cols" ]] && cols="100"

	# Remove 2 + 23 chars to accomodate the ammLib::Log header
	typeset -i size="$(( $cols - ${#name} - 26 ))"
	[[ $size -lt 0 ]] && size=20

	typeset -i i=0
	typeset bars=""
	for (( i=0; i < $(($size / 2)); i++ )); do
		bars+="="
	done

	echo "$bars $name $bars"

}

# @description  Mark a new step in the actions
# @args $1  (string) The name of the step to be displayed
function ammLog::StepBegin {
	typeset name="$1"

	typeset txt=">> Begin: $name"

	__AMMLOG_STEPNAME[$__AMMLOG_STEPDEPTH]="$name"
	__AMMLOG_STEPTIME[$__AMMLOG_STEPDEPTH]="$(date +%s)"

	ammLog::Info "$txt"

	__AMMLOG_STEPDEPTH+=1
}

# @description  Mark the end of a started step
# @arg $1  (int) return code
# @arg $2  (string) Message to be displayed
function ammLog::StepEnd {
	typeset -i ret="${1:-}"
	typeset    msg="${2:-}"

	if [[ $__AMMLOG_STEPDEPTH -le 0 ]]; then
		ammLog::Error "Cannot call ammLog::StepEnd while no step in progress. Callstack:"
		ammLog::Stackdump | ammLog::Error "-"
		return 1
	fi

	__AMMLOG_STEPDEPTH+=-1

	#typeset txt="$(ammLog::_StepPrefix $__AMMLOG_STEPDEPTH"
	typeset -i time="$(($(date +%s) - ${__AMMLOG_STEPTIME[$__AMMLOG_STEPDEPTH]} ))"
	typeset txt="<< End: ${__AMMLOG_STEPNAME[$__AMMLOG_STEPDEPTH]}. Took:${time}s"
	[[ -n "$ret" ]] && txt+=" Ret:'$ret'"
	[[ -n "$msg" ]] && txt+=" Msg:'$msg'"

	if [[ -z "$ret" ]]; then
		ammLog::Info "$txt"
	elif [[ $ret -eq 0 ]]; then
		ammLog::Info "$txt"
	else
		ammLog::Warning "$txt"
	fi

	__AMMLOG_STEPNAME[$__AMMLOG_STEPDEPTH]=""
	__AMMLOG_STEPTIME[$__AMMLOG_STEPDEPTH]=0
}

# @description  Display the stackdump of current script
# @arg $1  (int) Stack levels to skip. Default 1 (= skip this function)
# @arg $2  (int) Max levels to return. Default 255
function ammLog::Stackdump {
	typeset -i skip=${1:-1}
	typeset -i cnt=${2:-255}

	# Required for BASH_ARGV
	typeset    extdbg="$(shopt extdebug)"
	extdbg="${extdbg##*$'\t'}"

	typeset -i i j argoff=0
	# TODO: handle when called without file (stdin)
	for i in ${!BASH_SOURCE[@]}; do
		if [[ $i -lt $skip ]]; then
			argoff+=${BASH_ARGC[$i]:-0}
			continue
		fi
		[[ $i -ge $(($skip + $cnt)) ]] && break

		echo -n "${BASH_SOURCE[$i]##*/}:${BASH_LINENO[$(($i-1))]} ${FUNCNAME[$i]}() "
		if [[ "$extdbg" == "on" ]]; then
			j=$(($argoff + ${BASH_ARGC[$i]:-0} -1))
			while [[ $j -ge $argoff ]]; do
				#echo "j=$j argoff=$argoff ARGV=${BASH_ARGV[@]}"
				echo -n "'${BASH_ARGV[$j]}' "
				j+=-1
			done
		fi
		echo
		argoff+=${BASH_ARGC[$i]:-0}
	done
}

# @description  Log for a missing binary, and try to find the packages providing them
# @arg $@  List of missing binaries to search for
function ammLog::MissingBin {

	# Load the package modules
	if ! ammLib::Loadable pkg; then
		ammLog::Error "Cannot load pkg library. Cannot find required packages"
		return 1
	fi
	ammLib::Load pkg

	typeset binlist bin
	for binlist in "$@"; do
		for bin in $binlist; do
			ammPkg::InfoWhatProvides $bin
		done
	done
}

# @description  Disable or enable logging
# @arg $1  (string) Wanted state: 0 to disable logging, "onlyerr" to only log errors, anything else to enable logging
function ammLog::Silence {
	typeset enabled="$1"

	if [[ "$enabled" == "0" ]]; then
		__AMMLOG_SILENT=0
	elif [[ "$enabled" == "onlyerr" ]]; then
		__AMMLOG_SILENT=2
	else
		__AMMLOG_SILENT=1
	fi
}

# @description  Log xtrace as ammlog
# @noarg
function ammLog::TracingLog {
	# Check if bash trace is already enabled
	typeset undbg=""
	[[ "${-//x/}" == "$-" ]] && { undbg="set +x"; }
	set -x
	ammLog::Debug -
	$undbg
}

# @description  Enable tracing 'set -x' into dedicated file
function ammLog::TracingEnable {
	typeset dest="${1:-}"
	if [[ -z "$dest" ]]; then
		dest="$(ammLib::DataPathGet "tracing")"
	fi

	eval "exec $__AMMLOG_FDDBG>$dest"
	#eval "exec $__AMMLOG_FDDBG> >(ammLog::TracingLog)"
	BASH_XTRACEFD=$__AMMLOG_FDDBG
}


# @description  Log a message to the terminal (not through stdout). Only if session is interactive
# @arg $1  (string) message to be written
function ammLog::WriteTerm {
	typeset msg="$1"

	$__AMMLIB_INTERACTIVE || return 0

	echo > $__AMMLIB_TTY "$msg"
}

# -----------------------------------------------------------------------------
# System helpers
# -----------------------------------------------------------------------------

# @description  Get the ID of the current system
function ammSys::OSIdGet {

	if [[ -e "/etc/os-release" ]]; then
		(
			. "/etc/os-release"
			if [[ -n "${ID:-}" ]]; then
				echo "$ID"
			else
				return 1
			fi
		)
		[[ "$?" -eq 0 ]] && return
	fi

	typeset -a releases=(centos redhat gentoo debian ubuntu suse)
	typeset   release
	for release in "${releases}"; do
		if [[ -e "/etc/${release}-release" ]]; then
			echo "$release"
			return
		fi
	done

	echo "unknown"
}

# @description  Get the version of the current system
function ammSys::OSVersionGet {

	# Use generic os-release
	if [[ -e "/etc/os-release" ]]; then
		(
			. "/etc/os-release"
			if [[ -n "${VERSION_ID:-}" ]]; then
				echo "$VERSION_ID"
			else
				exit 1
			fi
		)
		[[ "$?" -eq 0 ]] && return
	fi

	# system doesn't have the LSB packages. Try custom
	typeset osid="$(ammSys::OSIdGet)"
	# Parse /etc/${osid}-release
	if [[ -s "/etc/${osid}-release" ]]; then
		typeset releaseStr="$(< "/etc/${osid}-release")"
		case $osid in
			gentoo) # Special case: use the profile version
				typeset profile="$(realpath "/etc/portage/make.profile")"
				profile="${profile##*/linux/}"
				profile="${profile#*/}"
				releaseStr="${profile%%/*}"
				;;
			centos|redhat)  # CentOS Linux release 7.7.1908 (Core) || CentOS Linux release 8.3.2011
				releaseStr="${releaseStr##*release }"
				releaseStr="${releaseStr%% *}"
				;;
			*)
				releaseStr=""
				;;
		esac
	fi

	# Debian /etc/${osid}_version
	if [[ -z "$releaseStr" ]] && [[ -s "/etc/${osid}_version" ]]; then
		typeset releaseStr="$(< "/etc/${osid}_version")"
		case $osid in
			debian|ubuntu)
				;;
			*)
				releaseStr=""
				;;
		esac
	fi

	if [[ -n "$releaseStr" ]]; then
		echo "$releaseStr"
		return 0
	fi

	echo "unknown"
}

# -----------------------------------------------------------------------------
# Environment helpers
# -----------------------------------------------------------------------------


function ammEnv::_Add {
	typeset var="$1"; shift
	typeset where="${1:-after}"
	if [[ "${1:-}" == "before" ]] || [[ "${1:-}" == "after" ]]; then
		where="$1"
		shift
	fi

	typeset p
	for p in "$@"; do
		if [[ -d "$p" ]]; then
			if [[ "$where" == "before" ]]; then
				eval export $var="$p:\$$var"
			else
				eval export $var="\$$var:$p"
			fi
		fi
	done
}

# @description  Add a path to PATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::PathAdd {
	ammEnv::_Add "PATH" "$@"
}

# @description  Add a path to LD_LIBRARY_PATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::LibAdd {
	ammEnv::_Add "LD_LIBRARY_PATH" "$@"
}

# @description  Add a path to MANPATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::ManAdd {
	ammEnv::_Add "MANPATH" "$@"
}

# @description  Check if given name is a function
# @exitcode 0  is a function
# @exitcode 1  is not a function
function ammEnv::IsFunc {
	[[ "$(type -t "$1")" == "function" ]]
}

function ammEnv::IsAlias {
	[[ "$(type -t "$1")" == "alias" ]]
}

# @description  Check if name if a variable
# @exitcode 0  is a defined variable
# @exitcode 1  is not a variable
function ammEnv::IsVar {
	typeset varname="$1"

	typeset var
	while read var; do
		[[ "$varname" == "${var%%=*}" ]] && return 0
	done < <(set -o posix; set)
	return 1
}

function ammEnv::VarExport {

	# TODO: Check for usage of "${var@A}" to export as array
	typeset varname vardef
	for varname in "$@"; do
		typeset multiline=false
		while read vardef; do
			if [[ "$varname" == "${vardef%%=*}" ]] || $multiline; then
				echo "$vardef"

				# If the def has spaces and does not end with '  it's a multiline
				typeset firstc="${vardef#$varname=}"
				firstc="${firstc:0:1}"
				typeset lastc="${vardef: -1:1}"
				[[ "$firstc" == "'" ]] && multiline=true
				[[ "$lastc" == "'" ]] && multiline=false
			fi

		done < <(set -o posix; set)
	done
}

function ammEnv::VarReturnArray {
	typeset varexp="$(ammEnv::VarExport "$1")"
	echo "${varexp#*=}"
}

# -----------------------------------------------------------------------------
# Path management helpers
# -----------------------------------------------------------------------------

# @description  Decompose a path to a list of all its folders
# @arg $1  (path) The path to decompose
function ammPath::Decompose {
	typeset path="$1"

	# If path exists, get its absolute value
	if [[ -e "$path" ]]; then
		path="$(realpath "$path")"
	# else, if path is not absolute either
	elif [[ "${path:0:1}" != "/" ]]; then
		path="$(realpath "$(pwd -P)")/$path"
	fi

	while [[ -n "$path" ]]; do
		echo "$path"
		path="${path%/*}"
	done
	echo "/"
}

# @description  Check if the full path of a file is secure for the current user
# @arg $1  (path) File or folder to check
# @exitcode 0   Path is secure
# @exitcode >=1  Path has a number of insecurities, shown as stdout
function ammPath::IsSecure {
	typeset path="$1"

	typeset -i r=0
	typeset d
	while read d; do
		typeset usr grp mod
		read usr grp mod < <(stat --dereference --format "%U %G %a" "$d")
		if [[ "$usr" != "root" ]] && [[ "$usr" != "$__AMMLIB_USERNAME" ]]; then
			echo "'$d' is owned by '$usr' (not root, nor $__AMMLIB_USERNAME)"
			r+=1
		fi
		if [[ $(( ${mod:1:1} & 2)) != 0 ]]; then
			echo "'$d' is group-writable for '$grp'"
			r+=1
		fi
		if [[ $(( ${mod:2:1} & 2)) != 0 ]]; then
			echo "'$d' is world-writable"
			r+=1
		fi
	done < <(ammPath::Decompose "$path")

	return $r
}

# @description  Check if we can create the requested path
# @arg $1  (path) File or folder to check
# @exitcode 0  Path is writable
function ammPath::IsWritable {
	typeset path="$1"

	typeset element
	while read element; do
		if [[ -e "$element" ]]; then
			if ! [[ -w "$element" ]]; then
				echo "Not writable: '$element'"
				return 1
			fi
			return 0
		fi
	done < <(ammPath::Decompose "$path")
	return 0
}

# @description  Check if a folder contains something
# @arg $1  (path) Path to the folder to check
function ammPath::IsEmpty {
	typeset path="$1"

	typeset i
	for i in "$path"/*; do
		# Skip virtual entries
		if [[ "$i" == "." ]] || [[ "$i" == ".." ]]; then
			continue
		fi

		# If anything else exists, it's not empty
		[[ -e "$i" ]] && return 1
	done

	return 0
}

# @description  Check if a path is valid
function ammPath::IsValid {
	typeset path="$1"

	# Early return for existing files or path
	[[ -d "$path" ]] && return 0
	[[ -e "$path" ]] && return 0
	[[ -z "$path" ]] && return 1

	# Decompose path
	typeset part= full=
	typeset -a parts=(${path//\// })
	typeset -i partId=0 partIdMax=$((${#parts[@]} -1))
	[[ "${path:0:1}" == "/" ]] && full="/"
	for partId in ${!parts[@]}; do
		part="${parts[$partId]}"
		full+="$part"
		# More parts to be processed after current one
		if [[ $partId -lt $partIdMax ]]; then
			if [[ -e "$full" ]] && ! [[ -d "$full" ]]; then
				ammLog::Debug "Path '$path' is invalid as '$full' is a file and would stop creation"
				return 1
			fi
		fi
		full+="/"
	done

	return 0
}

# @description  Copy a selection of files with their relative structure
# @arg $1  (path) Source path where to find the content
# @arg $2  (path) Destination path where to copy content
# @arg $@  (string) files or patterns to copy from source to destination
function ammPath::_RecurseFolders {
	typeset srcpath="$1"
	typeset dstpath="$2"
	typeset callback="$3"
	typeset force="$4"
	shift 4

	typeset -i r=0 rl=0
	typeset pattern srcdentry
	for pattern in "$@"; do
		# Remove srcpath from pattern, we'll add it after to ensure its present
		pattern="${pattern#$srcpath}"
		for srcdentry in "$srcpath/"$pattern; do
			typeset srcdir="${srcdentry%/*}"
			typeset dstdentry="${dstpath}${srcdentry#$srcpath}"
			typeset dstdir="${dstdentry%/*}"

			# Skip special folders (dotglob or pattern like .*)
			{ [[ "$srcdentry" == "." ]] || [[ "$srcdentry" == ".." ]]; } && continue

			if ! [[ -e "$srcdentry" ]]; then
				ammLog::Debug "Source '$srcdentry' does not exists. Skipping"
				continue
			fi

			# Do the operation by callback
			$callback "$srcdentry" "$dstdentry" "$force"
			rl=$?

			# If the callback returned false (operation failed) maybe log something
			if [[ $rl -ne 0 ]]; then
				ammLog::Warning "callback '$callback' failed to process '$srcdentry'"
				# If current pattern is a folder, recurse ourself into it
				if [[ -d "$srcdentry" ]]; then
				ammLog::Warning "Recursing into folder '$srcdentry' to process its elements"
				$FUNCNAME "$srcdentry" "$dstdentry" "$callback" "$force" "*" ".*"
					rl+=$?
				fi
			fi

			r+=$rl
		done
	done

	return $r
}

function ammPath::_CallbackCopy {
	typeset src="$1" dst="$2" force="${3:-false}"

	# Create parent destination directory
	typeset parent="${dst%/*}"
	[[ -d "$parent" ]] || mkdir -p "$parent"

	\cp -a "$src" "$dst"
}


function ammPath::_CallbackHardlink {
	typeset src="$1" dst="$2" force="${3:-false}"
	# Dest exists, check if same file for early return
	[[ -e "$dst" ]] && [[ "$src" -ef "$dst" ]] && return 0

	# Dest exists, but is not the target we want, move it or bail out
	if [[ -e "$dst" ]] && ! [[ -d "$dst" ]]; then
		if $force; then
			\mv "$dst" "$dst.old_$$_$(date +%s)"
		else
			return 1
		fi
	fi

	# Try to create the target as close as the source
	typeset -i r=0
	if [[ -d "$src" ]]; then
		mkdir --parents "$dst"
		r=$?
		chown --reference="$src" "$dst"
		chmod --reference="$src" "$dst"
	else
		ln "$src" "$dst"
		r=$?
	fi

	return $r
}


function ammPath::_CallbackSymlink {
	typeset src="$1" dst="$2" force="${3:-false}"
	# Dest exists, check if same file for early return
	[[ -e "$dst" ]] && [[ "$src" -ef "$dst" ]] && return 0

	# Move destination if exists
	if [[ -e "$dst" ]]; then
		if $force; then
			mv "$dst" "$dst.old.$$.$(date +%s)"
		else
			return 1
		fi
	fi

	# Create parent folder is not exists
	if ! [[ -d "${dst%/*}" ]]; then
		mkdir --parents "${dst%/*}" || return 1
	fi

	ln -s "$src" "$dst"
}

# @description  Copy a structure to another
# @arg $1
function ammPath::CopyStructure {
	typeset src="$1"
	typeset dst="$2"
	typeset force="$3"
	shift 3

	typeset -a patterns=("$@")
	[[ ${#patterns[@]} -eq 0 ]] && patterns+=(".")
	ammPath::_RecurseFolders "$src" "$dst" "ammPath::_CallbackCopy" "$force" "${patterns[@]}"
}

function ammPath::CopyStructureHardlinks {
	typeset src="$1"
	typeset dst="$2"
	typeset force="$3"
	shift 3

	typeset -a patterns=("$@")
	[[ ${#patterns[@]} -eq 0 ]] && patterns+=("*")
	ammPath::_RecurseFolders "$src" "$dst" "ammPath::_CallbackHardlink" "$force" "${patterns[@]}"
}

function ammPath::CopyStructureSymlinks {
	typeset src="$1"
	typeset dst="$2"
	typeset force="$3"
	shift 3

	typeset -a patterns=("$@")
	[[ ${#patterns[@]} -eq 0 ]] && patterns+=("*")
	ammPath::_RecurseFolders "$src" "$dst" "ammPath::_CallbackSymlink" "$force" "${patterns[@]}"
}

## Rsync for all in one
#if ammExec::Exists rsync; then
#	\rsync --perms --xattrs --owner --group --acls "$dentrysrc" "$dentrydst" 2>/dev/null
# Multi-bin call for safety

# -----------------------------------------------------------------------------
# Execution helpers
# -----------------------------------------------------------------------------

function ammExec::Logged {
	# TODO: Log the exec, return code and output of the command
	set -x
	"$@"
}

function ammExec::SudoIsAble {
	typeset runcmd="$1"
	typeset runuser="${2:-root}"

	typeset -i r=2

	typeset runuserdata="$(getent passwd "$runuser")"

	if [[ -z "$runuserdata" ]]; then
		ammLog::Error "Target user '$runuser' does not exists"
		return 1
	fi

	# Remove 3 firsts fields: username, password, uid
	typeset runusergid="${runuserdata#*:*:*:}"
	runusergid="${runusergid%%:*}"
	typeset runusergrp="$(getent group $runusergid)"
	runusergrp="${runusergrp%%:*}"

	typeset stmp="$(sudo -n -ll 2>/dev/null)"
	if [[ -n "$stmp" ]]; then
		typeset grantstarted=false
		typeset grantuseful=false
		# Pop in a subshell. Don't care about variable locality.
		echo "$stmp" | while read line; do

			#ammLog::Debug "== sudo line: '$line'"

			case "$line" in
				# Reset vars
				Sudoers\ entry:|LDAP\ Role:*)
					ammLog::Debug "New grant '$line'"
					grantstarted=true
					grantuseful=false
					;;

				# Check if line is useful for us
				RunAsUsers:*)
					typeset users="${line#*: }"
					for user in $users; do
						user="${user%,}"
						if [[ "$user" == "ALL" ]] || [[ "$user" == "$runuser" ]]; then
							ammLog::Debug " Grant '$line' useful for target user '$runuser' (direct access)"
							grantuseful=true
						fi

						case $user in
							# UID
							\#[0-9]*)
								typeset userdata="$(getent passwd ${user#\#})"
								if [[ "${userdata%%:*}" == "$runuser" ]]; then
									ammLog::Debug " Grant '$line' match UID of user '$runuser'"
									grantuseful=true
								fi
								;;

							# GID / Group
							%\#[0-9]*|%[a-zA-Z_]*)
								user="${user#%}"
								user="${user#\#}"
								if [[ "$user" == "$runusergid" ]] || [[ "$user" == "$runusergrp" ]]; then
									ammLog::Debug " Grant '$user' in '$line' match primary group of user '$runuser'"
									grantuseful=true
									break
								fi
								typeset members="$(getent group $user 2>/dev/null)"
								members="${members##*:}"
								for member in ${members//, /}; do
									if [[ "$member" == "$runuser" ]]; then
										ammLog::Debug " Grant '$user' in '$line' match membership of user '$runuser'"
										grantuseful=true
										break
									fi
								done
								;;

							# Netgroups
							+[a-zA-Z0-9_]*)
								typeset members="$(getent netgroup $user)"
								OIFS="$IFS"
								IFS='('
								for i in "$members"; do
									i="${i#*,}"
									i="${i%,*}"
									if [[ "$i" == "$runuser" ]]; then
										IFS="$OIFS"
										ammLog::Debug " Grant in '$line' match netgroup membership of user '$runuser'"
										grantuseful=true
										break
									fi
								done
								;;
							# TODO: User_Alias
							# TODO: negation
						esac
					done
					;;

				Options:*)
					;;

				Commands:)
					# Will eat stdin from parent loop
					while read cmd; do
						# Stop on empty newline to continue on parent loop
						[[ -z "$cmd" ]] && break

						# Keep in this loop to consume commands lines
						$grantuseful || continue

						# Most usual & easy cases: Wildcard, full bin or exact
						if [[ "$cmd" == "ALL" ]] ||
						   [[ "$cmd" == "${runcmd%% *}" ]] ||
						   [[ "$cmd" == "$runcmd" ]]; then
							ammLog::Debug " Matching '$cmd' for '$runcmd'"
							return 99
						fi

						# Glob matching (sudo is not regex)
						case "$runcmd" in
							$cmd)
								ammLog::Debug " Matching glob '$cmd' for '$runcmd'"
								return 99
								;;
						esac

					done
					;;

				*)
					# Skip error if we have not yet encountered a grant
					$grantstarted || continue

					ammLog::Warning "Unmanaged sudo grant line '$line'"
					;;
			esac
		done
		# Only use 99 return code as valid
		[[ $? == 99 ]] && r=0
	fi

	return $r
}


# @description  Execute a command as a different user
# @arg $1  (string) User to run the command as
# @arg $@  (string) the command to run, and its arguments. if "-", command is read from stdin
function ammExec::AsUser {
	typeset userrunas="${1:-$__AMMLIB_USERNAME}"; shift

	typeset usercurrent="$__AMMLIB_USERNAME"
	typeset -i ret=0
	typeset stmp

	# TODO: Add handling for 'setpriv'

	# Exec from stdin
	if [[ "$@" == "-" ]]; then

		# If no user specified, or we already are correct one...
		if [[ -z "$userrunas" ]] || [[ "$userrunas" == "$usercurrent" ]]; then
			eval "$(cat)" 98>&- 99>&-
			ret=$?

		# root... yay !
		elif [[ "$usercurrent" == "root" ]]; then
			# runuser is like su, but without PAM. Preferred when exec from root
			cat | runuser "$userrunas" 98>&- 99>&-
			ret=$?

		elif ammExec::Exists "sudo" && ammExec::SudoIsAble "ALL" "$userrunas"; then
			sudo -u "$userrunas" -i
			ret=$?
		else
			ammLog::Error "Cannot change from user $usercurrent to user $userrunas"
			ret=4
		fi

	# Exec from args
	else
		# No user specified, or already correct user
		if [[ -z "$userrunas" ]] || [[ "$userrunas" == "$usercurrent" ]]; then
			ammLog::Debug "Using eval to run as '$userrunas' cmd: '$@'"
			eval "$@" 98>&- 99>&-
			ret=$?

		# root... yay !
		elif [[ "$usercurrent" == "root" ]]; then
			ammLog::Debug "Using runuser to run as '$userrunas' cmd: '$*'"
			# I need to flatten
			# runuser is like su, but without PAM. Preferred when exec from root
			runuser -c "$*" "$userrunas" 98>&- 99>&-
			ret=$?

		# Maybe handle sudo ?
		#elif stmp="$(sudo -nll 2>/dev/null|awk 'p==1; /may run the following commands/{p=1;}')" && [[ -n "$stmp" ]]; then
		elif ammExec::Exists "sudo" && ammExec::SudoIsAble "$*" "$userrunas"; then
			ammLog::Debug "Using sudo to run as '$userrunas' cmd: '$@'"
			# TODO: parse $stmp output more...
			sudo -n -u "$userrunas" "$@" 98>&- 99>&-
			ret=$?

			# Fails...
		else
			ammLog::Error "Cannot exec '$@' as user $userrunas from user $usercurrent"
			ret=4
		fi

	fi

	return $ret
}

# @description:  Returns the full path of the first usable binary in $PATH
# @arg $1  (string) Binary to search in $PATH
# @exitcode 0  if binary was found
# @exitcode 1  if binary wat not found
function ammExec::GetPath {
	typeset bin="$1"

	typeset p
	for p in ${PATH//:/ }; do
		if [[ -x "$p/$bin" ]]; then
			echo "$p/$bin"
			return 0
		fi
	done
	return 1
}

# @description  Check if one or more command are available in PATH
# @arg $@  (string) the executables to search for
# @exitcode 0 if all are found
# @exitcode 1 if at least one is not found
function ammExec::Exists {

	typeset bin
	for bin in "$@"; do
		typeset binfound="" p
		for p in ${PATH//:/ }; do
			[[ -x "$p/$bin" ]] && {
				binfound="$p/$bin"
				break
			}
		done

		# If binary was not found in $PATH, stop here
		[[ -z "$binfound" ]] && return 1
	done
	return 0
}

# @description  Check if at least one given command is available in PATH
# @arg $@  (string) the executables to search for
# @exitcode 0 if at least one is found
# @exitcode 1 if none are found
function ammExec::RequestOne {
	typeset r=1
	typeset bin
	for bin in "$@"; do
		ammLog::Debug "Trying to find requested bin '$bin'"
		ammExec::Exists "$bin" && return 0
	done

	ammLog::Debug "Unable to find any of requested binaries '$@' in $PATH"
	return 1
}


# @description  Same as ammExecExists but calls ammLog::Die and terminate the script if any requested binary is not found
# @arg $@  (string) Binaries to search for in PATH
function ammExec::Require {
	typeset bin
	for bin in "$@"; do
		ammLog::Debug "Trying to find required bin '$bin'"
		if ! ammExec::Exists "$bin"; then
			ammLog::MissingBin "$bin"
			ammLog::Die "Unable to find required binary $bin in $PATH"
		fi
	done
	return 0
}

# @description  Same as ammExecRequestOne but calls ammLog::Die and terminates if none of requested binary is found
function ammExec::RequireOne {
	if ! ammExec::RequestOne "$@"; then
		ammLog::MissingBin "$@"
		ammLog::Die "Unable to find any of required binaries '$@' in $PATH"
	fi
	return 0
}

# @description  Check if provided path is executable
# @arg $1  Path to the file to be tested
function ammExec::IsExecutable {
	[[ -f "$1" ]] && [[ -x "$1" ]]
}


# Deprecated functions
function ammEnv::PathDecompose { ammLog::Deprecated "ammPath::Decompose"; }
function ammEnv::PathIsSecure { ammLog::Deprecated "ammPath::IsSecure"; }
function ammEnv::PathIsWritable { ammLog::Deprecated "ammPath::IsWritable"; }
function _ammLib::TrapInit { ammLog::Deprecated ammLib::_TrapInit "$@"; }
function _ammLib::TrapHandler { ammLog::Deprecated ammLib::_TrapHandler "$@"; }
function _ammEnv::Add { ammLog::Deprecated ammEnv::_Add "$@"; }
function _ammPath::RecurseFolders {  ammLog::Deprecated ammPath::_RecurseFolders "$@"; }
function _ammPath::CallbackCopy {    ammLog::Deprecated ammPath::_CallbackCopy "$@"; }
function _ammPath::CallbackHardlink { ammLog::Deprecated ammPath::_CallbackHardlink "$@"; }
function _ammPath::CallbackSymlink { ammLog::Deprecated ammPath::_CallbackSymlink "$@"; }

