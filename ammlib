# vim: ts=4 ft=sh

# AM Modular Library
# Main file, bootstrap and load dependencies
#
# To avoid uneeded library loading, some core / often used functions are here
# (they should be in their respective library file)

set -u

export LC_ALL=C

#
# Compatibility check
#

# Check if we are using bash, else try to load the wrapper
if [[ -z "$BASH" ]] || [[ "$(cat /proc/$$/comm)" != "bash" ]]; then
	# TODO Try to find a valid wrapper
	:
fi

#

if [[ "${BASH_VERSINFO[0]:-0}" -lt 4 ]]; then
	echo >&2 "This requires bash >= 4 to run."
	return 1 2>/dev/null
	exit 1
fi

if [[ -n "${AMMLIB_DEBUG:-}" ]]; then
	shopt -s extdebug
fi

#
# Interactive and other calling methods specifics
#

# Check if we are started by a valid stdin
typeset    __AMMLIB_TTY="$(tty)"
typeset    __AMMLIB_INTERACTIVE=true
if [[ -z "$__AMMLIB_TTY" ]] || ! [[ -e $__AMMLIB_TTY ]]; then
	__AMMLIB_TTY=""
	__AMMLIB_INTERACTIVE=false
fi

#
# Path management
#

# @description  Path where ammlib is
typeset    __AMMLIB_REALPATH="${BASH_SOURCE[0]}"

# Check the readlink usability
if type -t readlink >/dev/null; then
	[[ "$(readlink -f "$__AMMLIB_REALPATH")" -ef "$__AMMLIB_REALPATH" ]] || {
		echo "Readlink exists ($(type "readlink")) but does not behave properly."
		echo "Please check your existing environment before retrying. Stopping here."
		echo "(press any key to exit)"
		read -s -n 1 key
		exit 1
	}
fi

# @description  How the script was called ($0)
typeset -r  __AMMLIB_CALLNAME="$0"
# @description  Options passed to the script ($@)
typeset -a  __AMMLIB_CALLOPTS=("$@")
typeset -ra __AMMLIB_CALLOPTS_ORIG=("$@")
# Empty array being unset is fixed in bash 4.4
if [[ "${BASH_VERSINFO[0]}" -eq 4 ]] && [[ "${BASH_VERSINFO[1]}" -lt 4 ]]; then
	[[ -z "$@" ]] && __AMMLIB_CALLOPTS=("")
fi
# @description  The file that loaded ammlib
typeset -r  __AMMLIB_CALLFILE="${BASH_SOURCE[1]##*/}"
# @description  Path of the file that loaded ammlib
typeset -r  __AMMLIB_CALLPATH="${__AMMLIB_CALLNAME%/*}"

typeset -r  __AMMLIB_USERNAME="$(\id -nu)"
typeset -r  __AMMLIB_USERID="$(\id -u)"

#
# Set and create base folders to be used by library
#

# Library scripts base path
typeset __AMMLIB_ROOT="${__AMMLIB_REALPATH%/*}"

# Temporary data
typeset __AMMLIB_DATATMP="/tmp/.ammlib.${UID:-$(id -u)}/${__AMMLIB_CALLNAME##*/}.$$"
[[ -d "$__AMMLIB_DATATMP" ]] || mkdir -p "$__AMMLIB_DATATMP"

# Persistant data
typeset __AMMLIB_DATA="$HOME/.ammlib/data/"
[[ -d "$__AMMLIB_DATA" ]] || mkdir -p "$__AMMLIB_DATA"

# Custom binaries
typeset __AMMLIB_BIN="$HOME/.ammlib/bin"
[[ -d "$__AMMLIB_BIN" ]] || mkdir -p "$__AMMLIB_BIN"
export PATH+=":$__AMMLIB_BIN"

# -----------------------------------------------------------------------------
# Hooks and events
# -----------------------------------------------------------------------------

typeset -A __AMMLIB_HOOKLIST
# This module will register dynamic arrays based on name + prefix __AMMHOOK_

# @description  Will generate a variable ID from a given name
function ammLib::HookNameToVarname {
	typeset -u name="$1"

	# Remove any non-alphanum char
	name="${name//[^a-zA-Z0-9]/}"
	echo "__AMMLIB_HOOK_$name"
}

function ammLib::HookExists {
	typeset name="$1"

	typeset id="$(ammLib::HookNameToVarname "$name")"
	# Got to use eval, typeset -n is from bash 4.3
	eval "(set +u; [[ -n \${${id}} ]] )"
}

# @description  Register a callback to a hook
# @arg $1  (string) Name of the hook to register
# @arg $2  (function) Callback
function ammLib::HookRegister {
	typeset name="$1"; shift

	typeset varname="$(ammLib::HookNameToVarname "$name")"
	# Create the hook first if not existing
	if ! ammLib::HookExists $name; then
		ammLog::Dbg "Registering cb '$@' to new hook '$name'"
		eval "$varname=('$@')"
		__AMMLIB_HOOKLIST["$varname"]="$name"
	else
		ammLog::Dbg "Registering cb '$@' to existing hook '$name'"
		eval "$varname+=('$@')"
		__AMMLIB_HOOKLIST["$varname"]+=" $name"
	fi
}

function ammLib::HookList {
	echo "${!__AMMLIB_HOOKLIST[@]}"
}

# @description  List registered callbacks for an even
# @arg $1  (string) name of the hook to list callbacks
function ammLib::HookListCallbacks {
	typeset name="$1"

	typeset varname="$(ammLib::HookNameToVarname "$name")"
	typeset callback callbackid
	for callbackid in $(eval 'echo ${!'$varname'[@]}'); do
		eval echo '${'${varname}'['${callbackid}']};'
	done
}

# @description  Trigger a hook
# @arg $1  (string) Name of the hook to trigger
# @arg $@  (string) arguments to pass to the callbacks
function ammLib::HookTrigger {
	typeset name="$1"; shift

	ammLog::Dbg "Triggering callbacks for '$name'"

	typeset callback args
	while read callback args; do
		if ! ammEnv::IsFunc "$callback"; then
			ammLog::Wrn "Callback '$callback' is not a function. Skipping it"
			continue
		fi
		ammLog::Dbg "Calling callback '$callback $args' with '$@'"
		$callback $args "$@"
	done < <(ammLib::HookListCallbacks "$name")
}

# -----------------------------------------------------------------------------
# Exit code and trap management
# -----------------------------------------------------------------------------
typeset -A __AMMLIB_SIGNALS
typeset -A __AMMLIB_TRAP_CALLBACKS
typeset -A __AMMLIB_TRAP_REGISTERED
typeset -i __AMMLIB_TRAP_WAITMAX=30
typeset    __AMMLIB_TRAP_WAITSTEP=1

# @description:  Initialize and registers the signal handling trap
# @arg $@  Signals to be traped
function _ammLib::TrapInit {

	# Populate avaialble signals array from "trap -l" output
	if (set +u; [[ ${#__AMMLIB_SIGNALS[@]} -eq 0 ]]); then
		typeset s signum
		for s in "0)" "SIGEXIT" $(trap -l); do
			[[ "${s%)}" != "$s" ]] && signum="${s%)}"
			# Register num=>name and name=>num but skip invalid sigs
			if [[ "${s#SIG}" != "$s" ]] && [[ "${s#SIGRTM*}" == "$s" ]]; then
				__AMMLIB_SIGNALS[$signum]="${s#SIG}"
				__AMMLIB_SIGNALS[${s#SIG}]="$signum"
			fi
		done
	fi

	# Register trap with the signals as argument
	for s in "$@"; do
		trap "_ammLib::TrapHandler $s" "$s"
		__AMMLIB_TRAP_REGISTERED[$s]="ok"
	done
}

# @description:  Registers a callback
# @arg $1  The callback to call upon trap
# @arg $@  The signals to register on. Can be alises: EXITALL or EXITERR
function ammLib::TrapRegister {
	typeset callback="$1"; shift

	typeset signame
	for signame in "$@"; do
		case $signame in
			# Special alises
			EXITALL) ammLib::TrapRegister "$callback" EXIT HUP INT TERM QUIT ILL ABRT ;;
			EXITERR) ammLib::TrapRegister "$callback"      HUP INT TERM QUIT ILL ABRT ;;
			# Check for signal validity
			*)
				if (set -u; [[ -n "${__AMMLIB_SIGNALS[$signame]}" ]] ); then
					__AMMLIB_TRAP_CALLBACKS[$signame]+="$callback "
					if ! ( set +u; [[ -n "${__AMMLIB_TRAP_REGISTERED[$signame]}" ]] ); then
						ammLog::Dbg "Registered callback with uninit signal. Registering signal:$signame for callback:$callback"
						_ammLib::TrapInit "$signame"
					fi
				else
					ammLog::Wrn "Invalid signal to register callback: signal:$signame callback:$callback"
				fi
				;;
		esac
	done

}

function ammLib::TrapClean {
	# clean global temp vars
	if [[ -n ${AMMLIB_DEBUG:-} ]]; then
		if ( shopt -s nullglob dotglob; f=($__AMMLIB_DATATMP/*); [[ ${#f[@]} ]] ); then
			ammLog::Inf "Debug enabled: Keeping temporary path '$__AMMLIB_DATATMP'"
		else
			ammLog::Inf "Removing empty temporary path '$__AMMLIB_DATATMP'"
			[[ -d "$__AMMLIB_DATATMP" ]] && rmdir "$__AMMLIB_DATATMP"
		fi
	else
		[[ -d "$__AMMLIB_DATATMP" ]] && rm -fr "$__AMMLIB_DATATMP"
	fi
}

# Can't catch KILL CONT STOP
_ammLib::TrapInit EXIT HUP INT TERM QUIT ILL ABRT TSTP USR1 USR2
ammLib::TrapRegister "ammLib::TrapClean" EXITALL

# EXIT: Pseudo signal, standard exit of bash
# INT : Interrupt, Ctrl + C
# TERM: Default kill signal, graceful shutdown
# QUIT: Key "QUIT" (or Ctrl \) not on all keyboards
# ABRT: Call of abort(), usually by libc for ptmalloc errors
# TSTP: Stopped (Ctrl + Z)

# @description  (private) TRAP handler to clean
# @arg $1  Name of the signal
function _ammLib::TrapHandler {
	typeset retcode=$?
	typeset signame="$1"
	typeset sigtype=""
	typeset retaction="return"

	ammLog::Dbg "Caught signal '$signame' with retcode $retcode"
	case $signame in
		# Standard shutdown
		EXIT)
			sigtype="EXITOK"

			# Wait for unfinished jobs
			if [[ -n "$(jobs)" ]] && [[ $__AMMLIB_TRAP_WAITMAX -gt 0 ]]; then
				ammLog::Inf "Waiting unfinished jobs in background for $__AMMLIB_TRAP_WAITMAX checks every $__AMMLIB_TRAP_WAITSTEP sec"
				typeset num pid state cmd
				typeset -i waitjob=0
				while [[ $waitjob -lt $__AMMLIB_TRAP_WAITMAX ]]; do
					typeset -i jobcnt=0
					ammLog::Inf "== Check $waitjob $(ammLog::Time)"
					while read num pid state cmd; do
						[[ "$pid" == "$$" ]] && continue
						ammLog::Inf "PID:$pid State:$state Command:$cmd"
						jobcnt+=1
					done < <(jobs -lr)
					[[ $jobcnt -eq 0 ]] && break
					waitjob+=1
					sleep $__AMMLIB_TRAP_WAITSTEP
				done

				if [[ $waitjob -eq $__AMMLIB_TRAP_WAITMAX ]]; then
					ammLog::Wrn "Hit timeout before all background jobs finished. Remains:"
					jobs -l | ammLog::Wrn -
				fi
			fi
			;;

		# Manual stop
		INT|HUP|TERM|QUIT)
			sigtype="EXITERR"
			ammLog::Wrn "Caught graceful interruption $signame. Cleaning"
			retaction="exit"
			;;

		# Unamanged return code
		'')
			ammLog::Wrn "Called with empty signal name..."
			;;

		*)
			ammLog::Wrn "Unhandled signal name '$signame'"
			;;
	esac

	# Execute Callbacks for signame
	if ( set +u; [[ -n "${__AMMLIB_TRAP_CALLBACKS[$signame]}" ]] ); then
		typeset callback
		for callback in ${__AMMLIB_TRAP_CALLBACKS[$signame]}; do
			ammLog::Dbg "Calling callback $callback"
			$callback "$signame"
			ammLog::Dbg "Callback done. Retcode: $?"
		done
	fi

	# Do the exit or return
	$retaction $retcode
}


# -----------------------------------------------------------------------------
# Module loading
# -----------------------------------------------------------------------------
typeset __AMMLIB_SEARCHPATH="${__AMMLIB_ROOT}/lib"
typeset __AMMLIB_LOADED="ammlib lib"

# @description  Locate the library file matching given name
# @arg $1  (string) Name of the library to be loaded (eg, process)
# @stdout  (path) Path of the first matching file (in $__AMMLIB_SEARCHPATH)
function ammLib::Locate {
	typeset libname="$1"

	typeset libpath
	for libpath in $__AMMLIB_SEARCHPATH; do
			typeset nlib="${libpath}/${libname}.lib"
			[[ -r "$nlib" ]] && {
				echo "$nlib"
				return
			}
	done
}

# @description  Locate all libraries that starts with the given pattern
# @arg $1  The pattern to search against
# @stdout  (path) the list of libraries that matches the given pattern
function ammLib::LocatePattern {
	typeset libpattern="$1"

	typeset libpath lib
	for libpath in $__AMMLIB_SEARCHPATH; do
		for lib in $libpath/$libpattern*.lib; do
			echo "$lib"
		done
	done
}

# @descripton  return the library name of a given file
# @arg $1  (path) The file path to get the name from
# @stdout  (string) name of the library
function ammLib::NameFromPath {
	typeset path="$1"

	path="${path##*/}"
	path="${path%.lib}"

	echo "$path"
}

# @description  List all symbols and functions for packing
# @arg $@  (path[]) List of files to extract symbols from
function ammLib::GetSymbols {
	for file in "$@"; do
		grep -Po '^[\s]*(function[\s]+[^\s]+|[^\s]+\(\))[\s]*{' $file | awk '
			/function[ ]+([^ ]+)/ {print $2}
			/[^ ]+[ ]*()/ { gsub(/[()]/,"",$1); print $1 }'
		grep -Po '^[\s]*(typeset|declare|readonly)([\s]+-[a-zA-Z]+)?[\s]+__[^\s]+=' "$file" | awk '
			{gsub(/=$/,"",$NF); print $NF; }'
	done
}

# @description  Check if the given libname is a sub-library
# @exitcode  0 on success
function ammLib::IsSublib {
	typeset libname="$1"
	[[ "${libname//./}" != "$libname" ]]
}

# @description  Get the function name for the library' constructor
# @arg $1  (string) library name
function ammLib::MetaGetPrefix {
	typeset libname="$1"

	# Input name is lowercase. Up only first char: main => Main
	typeset funcpref="${libname^}"

	# If it's a sub-library, prefix is MainSub
	if ammLib::IsSublib "$libname"; then
		# Reset the prefix
		funcpref=""
		for f in ${libname//./ }; do
			funcpref+=${f^}
		done
	fi

	echo "amm${funcpref}::Meta"
}


# @description  Test if a library is loadable (it's requirements are met)
# @arg $@  (string[]) Name of the library
# @exitcode 0  If all modules are loadable
# @exitcode 1+ if one or more module cannot be loaded
function ammLib::Loadable {

	typeset -i r=0

	for libname in "$@"; do
		typeset libfile="$libname"

		# If the given path was a file, find its libname from path
		if [[ -e "$libfile" ]]; then
			libname="$(ammLib::NameFromPath $libfile)"
			#libname="${libfile##*/}"
			#libname="${libname%.lib}"
		# Else, find our file
		else
			libfile="$(ammLib::Locate "$libname")"
		fi

		# If the lib exists, load it
		if [[ -n "$libfile" ]] && [[ -s "$libfile" ]]; then

			# try to load it in a subshell to check init
			typeset metapref="$(ammLib::MetaGetPrefix "$libname")"
			typeset metatext=""

			# Display the lib file
			echo "$libfile"

			# check for features starting from bash 4.2 (typeset -g)
			if [[ "${BASH_VERSINFO[0]:-0}" -eq "4" ]] && [[ "${BASH_VERSINFO[1]:-0}" -lt 2 ]]; then
				if grep -P '(typeset|declare) -[a-zA-Z]*g[a-zA-Z]* ' $libfile >/dev/null 2>&1; then
					ammLog::Dbg "Library '$libfile' needs bash >= 4.2"
					r+=1
					continue
				fi
			fi

			# Code 98 = fail during the load (parsing error ?)
			metatext="$(ammLog::Silence onlyerr; . $libfile || exit 98; if \type ${metapref}Check >/dev/null 2>&1; then ${metapref}Check; exit $?; else exit 0; fi;)"

			# Dont stop loading, just log error and increase return
			if [[ $? -ne 0 ]]; then
				ammLog::Dbg "Unable to load lib '$libname' (file '$libfile'). Init check failed: '$metatext'"
				r=r+1
				continue
			fi

		# Unable to load the lib
		else
			ammLog::Dbg "Unable to locate library '$libname'"
			r+=1
		fi
	done

	return $r
}

# @description  Load a library
# @arg $@  (string[]) Library name to be loaded
# @exitcode 0 if all modules were loaded successfully
# @exitcode 1+ if one or more module failed to load
function ammLib::Load {
	typeset -i r=0

	ammLib::HookTrigger libload "$@"

	typeset libfile="" libname= l=
	for libname in "$@"; do

		libname="${libname//\"/}"
		libname="${libname//\'/}"

		# For submodule, you need to load parent module first
		if ammLib::IsSublib "$libname"; then

			# If the name is indeed a submodule, stop here
			typeset parentlib="${libname%.*}"
			typeset parentlibpath="$(ammLib::Locate "$parentlib")"
			if [[ -n "$parentlibpath" ]]; then

				typeset parentloaded=
				for l in $__AMMLIB_LOADED; do
					[[ "$l" == "$parentlib" ]] && parentloaded="$l"
				done

				if [[ -z "$parentloaded" ]]; then
					ammLog::Err "Cannot load '$libname' with ammLib::Load: look like a sub-lib of '$parentlib' and its parent '$parentlib' is not loaded"
					r=r+1
					continue
				fi
			fi
		fi

		# Skip already loaded libraries
		for l in $__AMMLIB_LOADED; do
			# Already loaded
			[[ "$libname" == "$l" ]] && continue 2
		done

		# Check if we can load requested lib
		libfile="$(ammLib::Loadable "$libname")"
		typeset libavailable=$?

		if [[ $libavailable -eq 0 ]]; then

			# Add lib early to avoid within-module reloading
			__AMMLIB_LOADED+=" $libname"

			# Init was ok, source and use lib
			. $libfile

			# Call init
			typeset metapref="$(ammLib::MetaGetPrefix "$libname")"
			ammEnv::IsFunc ${metapref}Init && ${metapref}Init

			continue

		else
			if [[ -n "$libfile" ]] && [[ -s "$libfile" ]]; then
				ammLog::Err "Unable to load lib '$libname' due to failed init (enable debug with AMMLIB_DEBUG=Lib for full detail)"
			else
				ammLog::Err "Unable to locate library '$libname' in search path '$__AMMLIB_SEARCHPATH'"
			fi

			r=r+1
		fi
	done

	return $r
}

# @description  Unload a module from the current session
# @arg $@   (string[]) List of modules to unload
function ammLib::Unload {
	typeset -i r=0

	ammLib::HookTrigger libunload "$@"

	# Find 
	typeset libname
	for libname in "$@"; do
		typeset libfile l
		# Check if lib was loaded
		for l in $__AMMLIB_LOADED; do
			# Not loaded
			[[ "$libname" == "$l" ]] && {
				libfile="$(ammLib::Locate "$libname")"
				continue
			}
		done

		# Skip non-loaded / non-found libraries
		[[ -z "$libfile" ]] && continue

		# Remove symbols (functions)
		typeset sym
		for sym in $(ammLib::GetSymbols "$libfile"); do
			unset $sym
		done

	done
}

# @description  Similar to ammLibLoad but exit if a module cannot be loaded
# @arg $@  (string[]) List of modules to be loaded
function ammLib::Require {
	for libname in "$@"; do

		# Spawn it in a subshell to accomodate all potential exec / checks
		ammLog::Dbg "Trying to load required lib '$libname'"
		if ! ammLib::Load "$libname"; then
			ammLog::Err "Unable to load required library '$libname'. Exiting"
			exit 1
		fi
	done

	return 0
}

# Compact all libraries to a single file, to be embedded in scripts
function ammLib::Compact {
	:
}

# @description List modules currently available
# @noargs
function ammLib::ListModules {

	typeset libpath lib
	for libpath in $(ammLib::LocatePattern); do
		[[ -s "$libpath" ]] || continue
		typeset lib=${libpath##*/}
		lib=${lib%.lib}

		echo
		echo "====== $lib ($libpath)"
	done
}

function ammLib::ListFunctions {
	typeset filename="${1:-}"

	typeset file
	for file in $(ammLib::LocatePattern $filename); do
		ammLib::GetSymbols "$file"
	done
}

# -----------------------------------------------------------------------------
# Embedded Logging
# -----------------------------------------------------------------------------

function _ammLog::ColorJoin {
	typeset IFS="$1"; shift
	echo "$*"
}

typeset -A __AMMLOG_TERMCODES=(
	# Set
	[reset]=0 [bold]=1 [dim]=2 [underline]=4 [blink]=5 [reverse]=7 [hidden]=8
	# Reset
	[resetbold]=21 [resetdim]=22 [resetunderline]=24 [resetblink]=25 [resetreverse]=27 [resethidden]=28
	# Foreground Colors
	[black]=30 [red]=31 [green]=32 [yellow]=33 [blue]=34 [magenta]=35 [cyan]=36 [white]=37 [default]=39
	# Background Colors
	[bgblack]=40 [bgred]=41 [bggreen]=42 [bgyellow]=43 [bgblue]=44 [bgmagenta]=45 [bgcyan]=46 [bgwhite]=47 [bgdefault]=49
	# Foreground Colors Light
	[lightred]=91 [lightgreen]=92 [lightyellow]=93 [lightblue]=94 [lightmagenta]=95 [lightcyan]=96 [lightwhite]=97
	# Background Colors Light
	[bglightblack]=100 [bglightred]=101 [bglightgreen]=102 [bglightyellow]=103 [bglightblue]=104 [bglightmagenta]=105 [bglightcyan]=106 [bglightwhite]=107 [bglightdefault]=109
)

typeset -i __AMMLOG_VERBOSITY=1
typeset -i __AMMLOG_DEPTH=0

# If no debug override has been done yet
[[ -n "$PS4" ]] && [[ "$PS4" != "+" ]] && {
	PS4=' (${BASH_SOURCE##*/}::${FUNCNAME[0]:-main}::$LINENO)  '
}

# @description  Colorize the text with values in __AMMLOG_TERMCODES
# @$ color codes to be printed
function ammLog::Color {
	typeset -r esc="\033["
	typeset -a codes=()

	while [[ -n "${1-}" ]]; do
		[[ -n "${__AMMLOG_TERMCODES[$1]-}" ]] && codes[${#codes[@]}+1]="${__AMMLOG_TERMCODES[$1]}"
		shift
	done

	echo -ne "${esc}$(_ammLog::ColorJoin ";" ${codes[@]+"${codes[@]}"})m"
}

# @description  Returns the Time for the logs
# @noargs
# @stdout  Date format HH:MM:SS
function ammLog::Time {
	date '+%H:%M:%S'
}

# @description  Returns the Date for the logs
# @noargs
# @stdout  Dat format yyyy-mm-dd
function ammLog::Date {
	date '+%y-%m-%d'
}


# Log will be out to stdout
typeset __AMMLOG_FDSTD=97
typeset __AMMLOG_FDERR=98
exec 97>&1 98>&2 # Must be plain int, not the variable
typeset __AMMLOG_FDDBG=99
typeset __AMMLOG_LOGFILE=""
typeset __AMMLOG_LOGTERM=""
typeset __AMMLOG_SILENT="0"

typeset -i __AMMLOG_STEPDEPTH=0
typeset -a __AMMLOG_STEPTIME
typeset -a __AMMLOG_STEPNAME

# @description  (private) Generic log function for logging
# @arg $1  (string) tag
# @arg $2  (string) format, passed to ammLog::Color, thus keys of $__AMMLOG_TERMCODES
# @arg $@  (string[]) Text to be logged. If only "-", read as stdin.
# @stdout  (string) Resulting log
function _ammLog::Log {
	# Remove tracing if enabled to limit spam
	typeset redbg=""
	[[ "${-//x/}" != "$-" ]] && { set +x; redbg="set -x"; }

	typeset tag="$1"; shift
	typeset fmt="$1"; shift

	typeset color="$(ammLog::Color $fmt)"
	typeset colorrst="$(ammLog::Color reset)"
	typeset date="$(ammLog::Time)"
	typeset pad="$(_ammLog::StepPad)"


	# Read stdin
	if [[ "$@" = "-" ]]; then
		while read line; do
			# Silent mode doesn't write any log
			if [[ "$__AMMLOG_SILENT" == "0" ]]; then
				echo >&$__AMMLOG_FDSTD -e "${color}[$date][$tag][$$]$pad $line${colorrst}"
			# Special case: only error on stdout
			elif [[ "$__AMMLOG_SILENT" == "2" ]] && [[ "$tag" == "ERR" ]]; then
				echo "[$date][$tag][$$]$pad $line"
			fi
		done

	# Standard args
	else
		# Silent mode doesn't display any log
		if [[ "$__AMMLOG_SILENT" == "0" ]]; then
			echo >&$__AMMLOG_FDSTD -e "${color}[$date][$tag][$$]$pad $@${colorrst}"
		elif [[ "$__AMMLOG_SILENT" == "2" ]] && [[ "$tag" == "ERR" ]]; then
			echo "[$date][$tag][$$]$pad $@"
		fi
	fi

	# Restart tracing if was enabled
	$redbg
}


function _ammLog::Write {
	typeset tar="$1"; shift
	typeset fmt="$2"; shift
	typeset color=""
}

# @description  Log a fatal error and terminate script
# @arg $@  Log text for fatal error. If "-", text is read from stdin
function ammLog::Die {
	_ammLog::Log "DIE" "bold red reverse" "$@"
	exit 255
}

# @description  Log an error
# @arg $@  Error text to log. If "-", text is read from stdin
function ammLog::Err {
	# TODO: add calling path
	_ammLog::Log "ERR" "bold red" "$@"
}

# @description  Log a warning
# @arg $@  warning text to log. If "-", text is read from stdin
function ammLog::Wrn {
	_ammLog::Log "WRN" "bold yellow" "$@"
}

# @description  Log an information
# @arg $@  Info text to log. If "-", text is read from stdin
function ammLog::Inf {
	_ammLog::Log "INF" "bold green" "$@"
}

function ammLog::_DbgIsEnabled {
	# Early tests
	[[ $__AMMLOG_VERBOSITY -ge 2 ]] && return 0
	[[ -z "${AMMLIB_DEBUG:-}" ]] && return 1
	[[ "$AMMLIB_DEBUG" == "all" ]] && return 0

	# Remove leading "amm"
	typeset func="${1##amm}"

	# If the lib is within the debug, or only the func
	if [[ "${AMMLIB_DEBUG//$func/}" != "$AMMLIB_DEBUG" ]] || [[ "$AMMLIB_DEBUG" =~ (^|,)${func%%::*}(,|$) ]]; then
		return 0
	fi
	return 1
}

# @description  Log a debug info
# @arg $@  Debug text to log. If "-", text is read from stdin
function ammLog::Dbg {

	# Remove tracing if enabled to limit spam
	typeset redbg=""
	[[ "${-//x/}" != "$-" ]] && { set +x; redbg="set -x"; }

	# Only send to log on verbose level
	#if [[ -n "${AMMLIB_DEBUG:-}" ]] || [[ $__AMMLOG_VERBOSITY -ge 2 ]]; then
	if ammLog::_DbgIsEnabled "${FUNCNAME[1]}"; then
		# Get the caller
		typeset callerdbg="${BASH_SOURCE[1]##*/}::${FUNCNAME[1]}::${BASH_LINENO[0]}"

		_ammLog::Log "DBG" "bold blue" "[$callerdbg] $@"

	# Else, we must consume stdin or bash will fail (and add to stack nonetheless)
	else
		if [[ "$1" == "-" ]]; then
			while read line; do
				: # echo "$line" >> "${__AMMLOG_DBGFILE}.${_AMMLOG_DEPTH}"
			done
		else
			: # echo "$@" >> "${__AMMLOG_DBGFILE}.${_AMMLOG_DEPTH}"
		fi
	fi

	# Restart tracing if was enabled
	$redbg
}

# @description  Log a warning about function deprecation
function ammLog::Deprecated {
	typeset replacement="$1"
	typeset message="${2:-}"

	typeset callee="$(ammLog::Stackdump 2 1)"
	typeset callstack="$(ammLog::Stackdump 3 1)"

	ammLog::Wrn "Function '$callee' (called from $callstack) is deprectated. Update your code to use '$replacement' instead"
	[[ -n "$message" ]] && ammLog::Wrn "  $message"
}


function _ammLog::StepPad {
	typeset step="${1:-$__AMMLOG_STEPDEPTH}"

	typeset i
	for (( i=0; i < $step; i++ )); do
		echo -n "  "
	done
}

# @description  Show a visible step separator
function ammLog::Step {
	typeset name="$1"

	typeset cols="${COLUMNS:-$(tput cols)}"
	[[ -z "$cols" ]] && cols="100"

	# Remove 2 + 23 chars to accomodate the ammLib::Log header
	typeset -i size="$(( $cols - ${#name} - 26 ))"
	[[ $size -lt 0 ]] && size=20

	typeset -i i=0
	typeset bars=""
	for (( i=0; i < $(($size / 2)); i++ )); do
		bars+="="
	done

	echo "$bars $name $bars"

}

# @description  Mark a new step in the actions
# @args $1  (string) The name of the step to be displayed
function ammLog::StepBegin {
	typeset name="$1"

	typeset txt="=> StepBegin: $name"

	__AMMLOG_STEPNAME[$__AMMLOG_STEPDEPTH]="$name"
	__AMMLOG_STEPTIME[$__AMMLOG_STEPDEPTH]="$(date +%s)"

	ammLog::Inf "$txt"

	__AMMLOG_STEPDEPTH+=1
}

# @description  Mark the end of a started step
# @arg $1  (int) return code
# @arg $2  (string) Message to be displayed
function ammLog::StepEnd {
	typeset -i ret="${1:-}"
	typeset    msg="${2:-}"

	if [[ $__AMMLOG_STEPDEPTH -le 0 ]]; then
		ammLog::Err "Cannot call ammLog::StepEnd while no step in progress. Callstack:"
		ammLog::Stackdump | ammLog::Err "-"
		return 1
	fi

	__AMMLOG_STEPDEPTH+=-1

	#typeset txt="$(_ammLog::StepPrefix $__AMMLOG_STEPDEPTH"
	typeset -i time="$(($(date +%s) - ${__AMMLOG_STEPTIME[$__AMMLOG_STEPDEPTH]} ))"
	typeset txt="<= StepEnd: ${__AMMLOG_STEPNAME[$__AMMLOG_STEPDEPTH]}. Took:${time}s"
	[[ -n "$ret" ]] && txt+=" Ret:'$ret'"
	[[ -n "$msg" ]] && txt+=" Msg:'$msg'"

	if [[ -z "$ret" ]]; then
		ammLog::Inf "$txt"
	elif [[ $ret -eq 0 ]]; then
		ammLog::Inf "$txt"
	else
		ammLog::Wrn "$txt"
	fi

	__AMMLOG_STEPNAME[$__AMMLOG_STEPDEPTH]=""
	__AMMLOG_STEPTIME[$__AMMLOG_STEPDEPTH]=0
}

# @description:  Display the stackdump of current script
# @arg $1  (int) Stack levels to skip. Default 1 (= skip this function)
# @arg $2  (int) Max levels to return. Default 255
function ammLog::Stackdump {
	typeset -i skip=${1:-1}
	typeset -i cnt=${2:-255}

	# Required for BASH_ARGV
	typeset    extdbg="$(shopt extdebug)"
	extdbg="${extdbg##*$'\t'}"

	typeset -i i j argoff=0
	for i in ${!BASH_SOURCE[@]}; do
		if [[ $i -lt $skip ]]; then
			argoff+=${BASH_ARGC[$i]:-0}
			continue
		fi
		[[ $i -ge $(($skip + $cnt)) ]] && break

		echo -n "${BASH_SOURCE[$i]##*/}::${FUNCNAME[$i]}::${BASH_LINENO[$(($i-1))]} "
		if [[ "$extdbg" == "on" ]]; then
			j=$(($argoff + ${BASH_ARGC[$i]:-0} -1))
			while [[ $j -ge $argoff ]]; do
				#echo "j=$j argoff=$argoff ARGV=${BASH_ARGV[@]}"
				echo -n "'${BASH_ARGV[$j]}' "
				j+=-1
			done
		fi
		echo
		argoff+=${BASH_ARGC[$i]:-0}
	done
}

# @description  Log for a missing binary, and try to find the packages providing them
# @arg $@  List of missing binaries to search for
function ammLog::MissingBin {

	# Load the package modules
	if ! ammLib::Loadable pkg; then
		ammLog::Err "Cannot load pkg library. Cannot find required packages"
		return 1
	fi
	ammLib::Load pkg

	typeset binlist bin
	for binlist in "$@"; do
		for bin in $binlist; do
			ammPkg::InfoWhatProvides $bin
		done
	done
}

# @description  Disable or enable logging
# @arg $1  (string) Wanted state: 0 to disable logging, "onlyerr" to only log errors, anything else to enable logging
function ammLog::Silence {
	typeset enabled="$1"

	if [[ "$enabled" == "0" ]]; then
		__AMMLOG_SILENT=0
	elif [[ "$enabled" == "onlyerr" ]]; then
		__AMMLOG_SILENT=2
	else
		__AMMLOG_SILENT=1
	fi
}

# Log xtrace (run in another process, and shares FD)
function ammLog::DebugStore {
	# Check if 
	typeset undbg=""
	[[ "${-//x/}" == "$-" ]] && { undbg="set +x"; }
	set -x
	ammLog::Dbg -
	$undbg
}

function ammLog::DebugEnable {
	exec $__AMMLOG_FDDBG> >(ammLog::DebugStore)
	BASH_XTRACEFD=$__AMMLOG_FDDBG
}

# @description  Log a message to the terminal (not through stdout). Only if session is interactive
# @arg $1  (string) message to be written
function ammLog::WriteTerm {
	typeset msg="$1"

	$__AMMLIB_INTERACTIVE || return 0

	echo > $__AMMLIB_TTY "$msg"
}

# -----------------------------------------------------------------------------
# Environment helpers
# -----------------------------------------------------------------------------

function _ammEnv::Add {
	typeset var="$1"; shift
	typeset where="${1:-after}"
	if [[ "${1:-}" == "before" ]] || [[ "${1:-}" == "after" ]]; then
		where="$1"
		shift
	fi

	typeset p
	for p in "$@"; do
		if [[ -d "$p" ]]; then
			if [[ "$where" == "before" ]]; then
				eval export $var="$p:\$$var"
			else
				eval export $var="\$$var:$p"
			fi
		fi
	done
}

# @description  Add a path to PATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::PathAdd {
	_ammEnv::Add "PATH" "$@"
}

# @description  Add a path to LD_LIBRARY_PATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::LibAdd {
	_ammEnv::Add "LD_LIBRARY_PATH" "$@"
}

# @description  Add a path to MANPATH
# @arg $1  (string)(optionnal). Can be "before" or "after" (default)
# @arg $@  (path[]) List of paths to be added to the env var
function ammEnv::ManAdd {
	_ammEnv::Add "MANPATH" "$@"
}

# @description  Check if given name is a function
# @exitcode 0  is a function
# @exitcode 1  is not a function
function ammEnv::IsFunc {
	[[ "$(type -t "$1")" == "function" ]]
}

function ammEnv::IsAlias {
	[[ "$(type -t "$1")" == "alias" ]]
}

# @description  Check if name if a variable
# @exitcode 0  is a defined variable
# @exitcode 1  is not a variable
function ammEnv::IsVar {
	typeset varname="$1"

	typeset var
	while read var; do
		[[ "$varname" == "${var%%=*}" ]] && return 0
	done < <(set -o posix; set)
	return 1
}
# -----------------------------------------------------------------------------
# Execution helpers
# -----------------------------------------------------------------------------

function ammExec::Logged {
	# TODO: Log the exec, return code and output of the command
	set -x
	"$@"
}

function ammExec::SudoIsAble {
	typeset runcmd="$1"
	typeset runuser="${2:-root}"

	typeset -i r=2

	typeset runuserdata="$(getent passwd "$runuser")"

	if [[ -z "$runuserdata" ]]; then
		ammLog::Err "Target user '$runuser' does not exists"
		return 1
	fi

	# Remove 3 firsts fields: username, password, uid
	typeset runusergid="${runuserdata#*:*:*:}"
	runusergid="${runusergid%%:*}"
	typeset runusergrp="$(getent group $runusergid)"
	runusergrp="${runusergrp%%:*}"

	typeset stmp="$(sudo -n -ll 2>/dev/null)"
	if [[ -n "$stmp" ]]; then
		typeset grantstarted=false
		typeset grantuseful=false
		# Pop in a subshell. Don't care about variable locality.
		echo "$stmp" | while read line; do

			#ammLog::Dbg "== sudo line: '$line'"

			case "$line" in
				# Reset vars
				Sudoers\ entry:|LDAP\ Role:*)
					ammLog::Dbg "New grant '$line'"
					grantstarted=true
					grantuseful=false
					;;

				# Check if line is useful for us
				RunAsUsers:*)
					typeset users="${line#*: }"
					for user in $users; do
						user="${user%,}"
						if [[ "$user" == "ALL" ]] || [[ "$user" == "$runuser" ]]; then
							ammLog::Dbg " Grant '$line' useful for target user '$runuser' (direct access)"
							grantuseful=true
						fi

						case $user in
							# UID
							\#[0-9]*)
								typeset userdata="$(getent passwd ${user#\#})"
								if [[ "${userdata%%:*}" == "$runuser" ]]; then
									ammLog::Dbg " Grant '$line' match UID of user '$runuser'"
									grantuseful=true
								fi
								;;

							# GID / Group
							%\#[0-9]*|%[a-zA-Z_]*)
								user="${user#%}"
								user="${user#\#}"
								if [[ "$user" == "$runusergid" ]] || [[ "$user" == "$runusergrp" ]]; then
									ammLog::Dbg " Grant '$user' in '$line' match primary group of user '$runuser'"
									grantuseful=true
									break
								fi
								typeset members="$(getent group $user 2>/dev/null)"
								members="${members##*:}"
								for member in ${members//, /}; do
									if [[ "$member" == "$runuser" ]]; then
										ammLog::Dbg " Grant '$user' in '$line' match membership of user '$runuser'"
										grantuseful=true
										break
									fi
								done
								;;

							# Netgroups
							+[a-zA-Z0-9_]*)
								typeset members="$(getent netgroup $user)"
								OIFS="$IFS"
								IFS='('
								for i in "$members"; do
									i="${i#*,}"
									i="${i%,*}"
									if [[ "$i" == "$runuser" ]]; then
										IFS="$OIFS"
										ammLog::Dbg " Grant in '$line' match netgroup membership of user '$runuser'"
										grantuseful=true
										break
									fi
								done
								;;
							# TODO: User_Alias
							# TODO: negation
						esac
					done
					;;

				Options:*)
					;;

				Commands:)
					# Will eat stdin from parent loop
					while read cmd; do
						# Stop on empty newline to continue on parent loop
						[[ -z "$cmd" ]] && break

						# Keep in this loop to consume commands lines
						$grantuseful || continue

						# Most usual & easy cases: Wildcard, full bin or exact
						if [[ "$cmd" == "ALL" ]] ||
						   [[ "$cmd" == "${runcmd%% *}" ]] ||
						   [[ "$cmd" == "$runcmd" ]]; then
							ammLog::Dbg " Matching '$cmd' for '$runcmd'"
							return 99
						fi

						# Glob matching (sudo is not regex)
						case "$runcmd" in
							$cmd)
								ammLog::Dbg " Matching glob '$cmd' for '$runcmd'"
								return 99
								;;
						esac

					done
					;;

				*)
					# Skip error if we have not yet encountered a grant
					$grantstarted || continue

					ammLog::Wrn "Unmanaged sudo grant line '$line'"
					;;
			esac
		done
		# Only use 99 return code as valid
		[[ $? == 99 ]] && r=0
	fi

	return $r
}

# @description  Execute a command as a different user
# @arg $1  (string) User to run the command as
# @arg $@  (string) the command to run, and its arguments. if "-", command is read from stdin
function ammExec::AsUser {
	typeset userrunas="${1:-$__AMMLIB_USERNAME}"; shift

	typeset usercurrent="$__AMMLIB_USERNAME"
	typeset -i ret=0
	typeset stmp

	# Exec from stdin
	if [[ "$@" == "-" ]]; then

		# If no user specified, or we already are correct one...
		if [[ -z "$userrunas" ]] || [[ "$userrunas" == "$usercurrent" ]]; then
			eval "$(cat)" 98>&- 99>&-
			ret=$?

		# root... yay !
		elif [[ "$usercurrent" == "root" ]]; then
			# runuser is like su, but without PAM. Preferred when exec from root
			cat | runuser -m "$userrunas" 98>&- 99>&-
			ret=$?

		elif ammExec::Exists "sudo" && ammExec::SudoIsAble "ALL" "$userrunas"; then
			sudo -u "$userrunas" -i
		else
			ammLog::Err "Cannot change from user $usercurrent to user $userrunas"
			ret=4
		fi

	# Exec from args
	else
		# No user specified, or already correct user
		if [[ -z "$userrunas" ]] || [[ "$userrunas" == "$usercurrent" ]]; then
			ammLog::Dbg "Using eval to run as '$userrunas' cmd: '$@'"
			eval "$@" 98>&- 99>&-
			ret=$?

		# root... yay !
		elif [[ "$usercurrent" == "root" ]]; then
			ammLog::Dbg "Using su to run as '$userrunas' cmd: '$*'"
			# I need to flatten
			# runuser is like su, but without PAM. Preferred when exec from root
			runuser -m -c "$*" "$userrunas" 98>&- 99>&-
			ret=$?

		# Maybe handle sudo ?
		elif stmp="$(sudo -nll 2>/dev/null|awk 'p==1; /may run the following commands/{p=1;}')" && [[ -n "$stmp" ]]; then
			ammLog::Dbg "Using sudo to run as '$userrunas' cmd: '$@'"
			# TODO: parse $stmp output more...
			sudo -n -u "$userrunas" "$@" 98>&- 99>&-
			ret=$?

			# Fails...
		else
			ammLog::Err "Cannot exec '$@' as user $userrunas from user $usercurrent"
			ret=4
		fi

	fi

}

function ammExec::GetPath {
	typeset bin="$1"

	typeset p
	for p in ${PATH//:/ }; do
		[[ -x "$p/$bin" ]] && echo "$p/$bin"
	done
}

# @description  Check if one or more command are available in PATH
# @arg $@  (string) the executables to search for
# @exitcode 0 if all are found
# @exitcode 1 if at least one is not found
function ammExec::Exists {

	typeset bin
	for bin in "$@"; do
		typeset binfound="" p
		for p in ${PATH//:/ }; do
			[[ -x "$p/$bin" ]] && {
				binfound="$p/$bin"
				break
			}
		done

		# If binary was not found in $PATH, stop here
		[[ -z "$binfound" ]] && return 1
	done
	return 0
}

# @description  Check if at least one given command is available in PATH
# @arg $@  (string) the executables to search for
# @exitcode 0 if at least one is found
# @exitcode 1 if none are found
function ammExec::RequestOne {
	typeset r=1
	typeset bin
	for bin in "$@"; do
		ammLog::Dbg "Trying to find requested bin '$bin'"
		ammExec::Exists "$bin" && return 0
	done

	ammLog::Dbg "Unable to find any of requested binaries '$@' in $PATH"
	return 1
}


# @description  Same as ammExecExists but calls ammLog::Die and terminate the script if any requested binary is not found
# @arg $@  (string) Binaries to search for in PATH
function ammExec::Requires {
	typeset bin
	for bin in "$@"; do
		ammLog::Dbg "Trying to find required bin '$bin'"
		if ! ammExec::Exists "$bin"; then
			ammLog::MissingBin "$bin"
			ammLog::Die "Unable to find required binary $bin in $PATH"
		fi
	done
	return 0
}

# @description  Same as ammExecRequestOne but calls ammLog::Die and terminates if none of requested binary is found
function ammExec::RequiresOne {
	if ! ammExec::RequestOne "$@"; then
		ammLog::MissingBin "$@"
		ammLog::Die "Unable to find any of required binaries '$@' in $PATH"
	fi
	return 0
}

